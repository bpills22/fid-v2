"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../constants");
/**
 * Validates a remote pattern (url)
 * and returns true if it's valid image URL
 * according to the next.js config, otherwise false.
 * @param nextConfig The next.js config
 * @param url The url to validate
 * @returns {boolean}
 */
function isValidRemotePattern(nextConfig, url) {
    var _a, _b, _c, _d;
    const parsedUrl = new URL(url, 'http://127.0.0.1');
    const remoteDomains = (_b = (_a = nextConfig === null || nextConfig === void 0 ? void 0 : nextConfig.images) === null || _a === void 0 ? void 0 : _a.domains) !== null && _b !== void 0 ? _b : [];
    const remotePatterns = (_d = (_c = nextConfig === null || nextConfig === void 0 ? void 0 : nextConfig.images) === null || _c === void 0 ? void 0 : _c.remotePatterns) !== null && _d !== void 0 ? _d : [];
    // Don't allow to proxy images to itself
    if (parsedUrl === null || parsedUrl === void 0 ? void 0 : parsedUrl.pathname.startsWith(constants_1.EDGIO_IMAGE_PROXY_PATH)) {
        return false;
    }
    // If the image is from a remote domain, check if it's allowed
    if (remoteDomains.find(domain => {
        return domain === `${parsedUrl.hostname}${parsedUrl.port ? `:${parsedUrl.port}` : ''}`;
    })) {
        return true;
    }
    // If the image is from a remote pattern, check if it's allowed
    return !!remotePatterns.find(({ hostname, pathname, protocol = parsedUrl.protocol, port = parsedUrl.port }) => {
        // The hostname and pathname can contain wildcard patterns:
        // '*' - match a single path segment or subdomain
        // '**' - match any number of path segments at the end of subdomain or at the beginning
        const hostnameRegex = hostname ? hostnameToRegex(hostname) : /.*/;
        const pathnameRegex = pathname ? pathnameToRegex(pathname) : /.*/;
        return (hostnameRegex.test(parsedUrl.hostname) &&
            pathnameRegex.test(parsedUrl.pathname) &&
            protocol.replace(':', '') === parsedUrl.protocol.replace(':', '') &&
            port.toString() === parsedUrl.port.toString());
    });
}
exports.default = isValidRemotePattern;
/**
 * Converts a hostname pattern to a regex
 * with support for wildcard patterns
 * and . (dot) character as segments delimiter.
 * @param hostname The hostname pattern
 */
function hostnameToRegex(hostname) {
    return new RegExp(`^${hostname.replace(/\*\*/g, '(.+)?').replace(/\*/g, '[^.]+')}$`);
}
/**
 * Converts a pathname pattern to a regex
 * with support for wildcard patterns
 * and / (slash) character as segments delimiter.
 * @param pathname The pathname pattern
 */
function pathnameToRegex(pathname) {
    return new RegExp(`^${pathname.replace(/\*\*/g, '(.+)?').replace(/\*/g, '[^/]+')}/?$`);
}
