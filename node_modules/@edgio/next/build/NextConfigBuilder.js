"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const fs_1 = require("fs");
const constants_1 = require("../config/constants");
const nft_1 = require("@vercel/nft");
const getNextConfig_1 = __importDefault(require("../getNextConfig"));
const chalk_1 = __importDefault(require("chalk"));
const cross_spawn_1 = __importDefault(require("cross-spawn"));
const constants_2 = require("../constants");
const paths_1 = require("@edgio/core/deploy/paths");
/**
 *  NextConfigBuilder creates the buildtime version and runtime version of next.config.js file.
 *  The runtime version is the original version of next.config.js file.
 *
 *  This nextConfigHandler serves Next config.
 *  For performance reason when no publicRuntimeConfig or serverRuntimeConfig property is presented,
 *  only the buildtime version of config is returned, otherwise the runtime version is evaluated
 *  and publicRuntimeConfig and serverRuntimeConfig properties added.
 */
class NextConfigBuilder {
    constructor(srcDir, destDir, options = {}) {
        var _a, _b, _c, _d;
        this.skipNodeModules = true;
        this.srcDir = srcDir;
        this.destDir = destDir;
        this.nextRootDir = options.nextRootDir || './';
        // Get absolute path to the root directory of the project
        // from where dependencies should be traced.
        // For example:
        // srcDir: /repo/packages/next/src
        // destDir: /repo/packages/next/.edgio/lambda/app
        // nextRootDir: packages/next
        // fileTracingRootDir: /repo/
        this.fileTracingRootDir = (0, path_1.resolve)((0, path_1.relative)((0, path_1.resolve)(this.nextRootDir), this.srcDir));
        // If next.config.js does not have runtime config, we can skip node_modules tracing
        // to save time and space because next.config.runtime.js won't be ever run in lambda.
        const hasRuntimeConfig = ((_a = options.nextConfig) === null || _a === void 0 ? void 0 : _a.serverRuntimeConfig) || ((_b = options.nextConfig) === null || _b === void 0 ? void 0 : _b.publicRuntimeConfig);
        this.skipNodeModules = (_c = options.skipNodeModules) !== null && _c !== void 0 ? _c : !hasRuntimeConfig;
        // Find used next.config file in the project source directory
        const srcFile = [
            (0, path_1.join)(srcDir, 'next.config.ts'),
            (0, path_1.join)(srcDir, 'next.config.mjs'),
            (0, path_1.join)(srcDir, 'next.config.cjs'),
            (0, path_1.join)(srcDir, 'next.config.js'),
        ].find(fs_1.existsSync);
        if (!srcFile) {
            throw new Error('Next config file was not found. Please create next.config.js in the root directory of your project.');
        }
        this.srcFile = srcFile;
        this.nextConfig = options.nextConfig;
        this.generateSourceMap = (_d = options.generateSourceMap) !== null && _d !== void 0 ? _d : true;
    }
    /**
     * Returns the list of next.config.js file dependencies
     * such as imported modules, json files, native modules etc...
     * We cannot just bundle them, because some of them might have dynamic imports,
     * ESM syntax not convertible to CJS, etc...
     * and we need to trace them to the root of the project.
     * For example: @next/bundle-analyzer depends on SWC binaries.
     * @return
     */
    async getDependencies() {
        const { fileList } = await (0, nft_1.nodeFileTrace)([this.srcFile], {
            // Trace dependencies by default from the same directory as the next.config.js file
            // and if nextRootDir is set, trace dependencies from the nextRootDir directory.
            // For example: ../../
            base: this.fileTracingRootDir,
            processCwd: this.srcDir,
            ts: true,
            // When we build next.config.ts locally just for dev mode,
            // we can skip node_modules tracing to speed up the build.
            ignore: file => this.skipNodeModules && !!file.match(/node_modules|.yalc/),
        });
        return Array.from(fileList)
            // Workaround just for our .yalc symlinks that points to different directories
            .map((file) => file.replace('.yalc', 'node_modules'));
    }
    /**
     * Copies the dependencies to lambda folder
     * @return
     */
    async copyDependencies(dependencies) {
        for (const srcFileRelative of dependencies) {
            const srcFile = (0, path_1.join)(this.fileTracingRootDir, srcFileRelative);
            const srcFileRelativeDir = (0, path_1.dirname)(srcFileRelative);
            const destFile = (0, path_1.join)(this.destDir, srcFileRelative);
            const destFileDir = (0, path_1.join)(this.destDir, srcFileRelativeDir);
            // Do not copy the original next.config.js file as dependency of itself
            if (this.srcFile === srcFile) {
                continue;
            }
            // Do not copy directories, non-existing files or symlinks
            if (!(0, fs_1.existsSync)(srcFile) || !(0, fs_1.statSync)(srcFile).isFile()) {
                continue;
            }
            // Create the directory structure if it does not exist
            if (!(0, fs_1.existsSync)(destFileDir)) {
                (0, fs_1.mkdirSync)(destFileDir, { recursive: true });
            }
            (0, fs_1.copyFileSync)(srcFile, destFile);
            // If the dependency is TS file, we need to compile it to JS
            if (destFile.endsWith('.ts'))
                await this.compileTs(destFile);
        }
    }
    /**
     * Compiles TS dependencies to JS
     */
    async compileTs(srcFile) {
        var _a;
        const result = cross_spawn_1.default.sync('npx', [
            'esbuild',
            '--platform=node',
            '--minify',
            '--target=es6',
            '--format=cjs',
            ...(this.generateSourceMap ? ['--sourcemap'] : []),
            '--outfile=' + srcFile.replace(/\.ts$/, '.js'),
            srcFile,
        ], {
            stdio: 'pipe',
            cwd: this.srcDir
        });
        if (result.status !== 0) {
            console.error(chalk_1.default.red("> Failed to compile Typescript dependency of next config:"));
            console.error(chalk_1.default.red(`> Dependency: ${srcFile}`));
            if (result.error)
                throw result.error;
            throw new Error((_a = result.stderr) === null || _a === void 0 ? void 0 : _a.toString());
        }
    }
    /**
     * Creates the file with runtime version of next.config.js.
     * This file is same as the original one.
     * @return
     */
    async writeRuntimeVersion() {
        var _a;
        const result = cross_spawn_1.default.sync('npx', [
            // IMPORTANT: Do not put --bundle flag here,
            // because it will fail on native modules such as @next/bunle-analyzer in most cases.
            'esbuild',
            '--platform=node',
            '--minify',
            '--target=es6',
            '--format=cjs',
            ...(this.generateSourceMap ? ['--sourcemap'] : []),
            '--outfile=' + (0, path_1.join)(this.destDir, this.nextRootDir, constants_1.NEXT_RUNTIME_CONFIG_FILE),
            this.srcFile,
        ], {
            stdio: 'pipe',
            cwd: this.srcDir
        });
        if (result.status !== 0) {
            console.error(chalk_1.default.red("> Failed to build next config file (runtime version)"));
            if (result.error)
                throw result.error;
            throw new Error((_a = result.stderr) === null || _a === void 0 ? void 0 : _a.toString());
        }
    }
    /**
     * Creates the file with buildtime version of next.config.js.
     * Thi file captures the next.config.js content at build time.
     * @return
     */
    async writeBuildtimeVersion() {
        this.nextConfig = this.nextConfig || (0, getNextConfig_1.default)((0, path_1.join)(this.destDir, this.nextRootDir), constants_1.NEXT_RUNTIME_CONFIG_FILE);
        // All variables in domains config field are resolved during build time but
        // the process.env.EDGIO_IMAGE_OPTIMIZER_HOST is available during runtime.
        // In order to make the next/image optimizer work with assets on S3,
        // we need to replace 'SET_EDGIO_PERMALINK_HOST_HERE' by process.env.EDGIO_PERMALINK_HOST
        // or legacy process.env.EDGIO_IMAGE_OPTIMIZER_HOST when build finish.
        // TODO: Remove EDGIO_IMAGE_OPTIMIZER_HOST here when console-api sets the EDGIO_PERMALINK_HOST env var
        const serverConfigSrc = `module.exports=${JSON.stringify(this.nextConfig)}`.replace(/["']SET_EDGIO_PERMALINK_HOST_HERE["']/, 'process.env.EDGIO_PERMALINK_HOST || process.env.EDGIO_IMAGE_OPTIMIZER_HOST');
        (0, fs_1.writeFileSync)((0, path_1.join)(this.destDir, this.nextRootDir, constants_1.NEXT_BUILDTIME_CONFIG_FILE), serverConfigSrc);
    }
    /**
     * Creates the file with our handler which will return the next config
     * either from captured buildtime version or runtime version.
     * @return
     */
    async writeFinalVersion() {
        var _a;
        (0, fs_1.copyFileSync)((0, path_1.join)(__dirname, 'nextConfigHandler.js'), (0, path_1.join)(this.destDir, this.nextRootDir, constants_1.NEXT_CONFIG_HANDLER_FILE));
        const result = cross_spawn_1.default.sync('npx', [
            'esbuild',
            '--platform=node',
            '--target=es6',
            '--bundle',
            '--minify',
            '--format=cjs',
            ...(this.generateSourceMap ? ['--sourcemap'] : []),
            '--outfile=' + (0, path_1.join)(this.destDir, this.nextRootDir, constants_1.NEXT_CONFIG_FILE),
            `--external:./${constants_1.NEXT_RUNTIME_CONFIG_FILE}`,
            (0, path_1.join)(this.destDir, this.nextRootDir, constants_1.NEXT_CONFIG_HANDLER_FILE)
        ], {
            stdio: 'pipe',
            cwd: this.destDir
        });
        if (result.status !== 0) {
            console.error(chalk_1.default.red("> Failed to build next config file (final version)"));
            if (result.error)
                throw result.error;
            throw new Error((_a = result.stderr) === null || _a === void 0 ? void 0 : _a.toString());
        }
    }
    /**
     * Executes the build of next config file and bundle nextConfigHandler together with buildtime version of next.config.js.
     * Then clean after ourselves.
     * @return
     */
    async build() {
        process.stdout.write(`> Building next config... `);
        this.addNextRootDirFile();
        await this.copyDependencies(await this.getDependencies());
        await this.writeRuntimeVersion();
        await this.writeBuildtimeVersion();
        await this.writeFinalVersion();
        this.cleanAfterBuild();
        process.stdout.write(`done.\r\n`);
    }
    /**
     * Adds file with nextRootDir to the lambda directory,
     * so we know where to look for the next project files, next.config.js etc...
     * This is needed for the projects in NPM/YARN workspaces.
     */
    addNextRootDirFile() {
        (0, fs_1.mkdirSync)((0, path_1.resolve)(paths_1.JS_APP_DIR), { recursive: true });
        (0, fs_1.writeFileSync)((0, path_1.resolve)(paths_1.JS_APP_DIR, constants_2.NEXT_ROOT_DIR_FILE), this.nextRootDir);
    }
    /**
     * Removes the unused files after the build
     * @return
     */
    cleanAfterBuild() {
        // Handler was replaced by bundled version
        (0, fs_1.unlinkSync)((0, path_1.join)(this.destDir, this.nextRootDir, constants_1.NEXT_CONFIG_HANDLER_FILE));
        // The buildtime version is no longer needed because it's included in bundle
        (0, fs_1.unlinkSync)((0, path_1.join)(this.destDir, this.nextRootDir, constants_1.NEXT_BUILDTIME_CONFIG_FILE));
    }
}
exports.default = NextConfigBuilder;
