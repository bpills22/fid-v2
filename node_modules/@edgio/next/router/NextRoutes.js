"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const environment_1 = require("@edgio/core/environment");
const nextPathFormatter_1 = __importDefault(require("./nextPathFormatter"));
const getDistDir_1 = require("../util/getDistDir");
const path_1 = require("path");
const Router_1 = __importDefault(require("@edgio/core/router/Router"));
const RouteCriteria_1 = require("@edgio/core/router/RouteCriteria");
const config_1 = require("@edgio/core/config");
const getNextConfig_1 = __importDefault(require("../getNextConfig"));
const origins_1 = require("@edgio/core/origins");
const cacheConfig_1 = require("./cacheConfig");
const ManifestParser_1 = __importDefault(require("./ManifestParser"));
const constants_1 = require("../constants");
const chalk_1 = __importDefault(require("chalk"));
const core_1 = require("@edgio/core");
const types_1 = require("../types");
const getRenderMode_1 = __importDefault(require("../util/getRenderMode"));
const qs_1 = __importDefault(require("qs"));
const ParamsExtractor_1 = __importDefault(require("@edgio/core/router/ParamsExtractor"));
const setNextPage_1 = __importDefault(require("./setNextPage"));
const getBuildId_1 = __importDefault(require("../util/getBuildId"));
const bindParams_1 = __importDefault(require("@edgio/core/utils/bindParams"));
const path_2 = require("@edgio/core/router/path");
const path_to_regexp_1 = require("path-to-regexp");
const toEdgeRegex_1 = __importDefault(require("@edgio/core/utils/toEdgeRegex"));
const getNextRootDir_1 = __importDefault(require("../util/getNextRootDir"));
const isValidRemotePattern_1 = __importDefault(require("../util/isValidRemotePattern"));
class NextRoutes {
    /**
     * Provides next registered routes to router
     * @param nextRootDir The root directory for the Next.js app
     */
    constructor(nextRootDir) {
        this.locales = [];
        this.redirects = [];
        this.pages = [];
        this.pagesMap = {};
        this.middlewares = [];
        this.buildId = 'dev';
        this.ssrOptions = {};
        /**
         * The FeatureCreator which proxies all requests to Next in serverless.
         */
        this.ssrHandler = (routeHelper) => {
            var _a;
            // We are requesting a 404 error page by default in serverless mode.
            // This request header is later replaced by the actual page name
            // in addPage() method if it exists.
            if (this.renderMode === types_1.RENDER_MODES.serverless)
                (0, setNextPage_1.default)('404', routeHelper);
            // Special case for 404 error page with revalidation.
            // If 404 page has revalidation, we'll cache it on the edge for time specified in cache-control header returned by Next.js
            // unless cache-control header is set to private, no-cache or no-store.
            // @example cache-control: s-maxage=10, stale-while-revalidate
            if ((_a = this.pagesMap['/404']) === null || _a === void 0 ? void 0 : _a.hasRevalidation) {
                routeHelper.cache({
                    cacheableStatusCodes: [404],
                });
            }
            routeHelper.proxy(origins_1.SERVERLESS_ORIGIN_NAME, {
                transformRequest: async (req) => {
                    var _a, _b, _c, _d;
                    if (this.renderMode === types_1.RENDER_MODES.serverless)
                        this.addPageParamsToQuery(req);
                    // Check if any middleware matches the request path
                    // NOTE: We can also loop through pages and match those that have revalidation
                    // and exclude them, but it's faster to loop through middlewares as there are fewer of them
                    // most of the time.
                    const matchedMiddleware = this.middlewares.find(middleware => middleware.matchers.some(matcher => new RegExp(matcher.regexp).test(req.path)));
                    // Exit early if middleware is matched, so 'x-prerender-revalidate' header is not set.
                    if (matchedMiddleware)
                        return;
                    // Check if the request has the prerender bypass cookie set.
                    const cookie = (_a = req.getHeader(core_1.HTTP_HEADERS.cookie)) === null || _a === void 0 ? void 0 : _a.toString();
                    const bypassPrerender = cookie === null || cookie === void 0 ? void 0 : cookie.includes(`${constants_1.NEXT_PRERENDER_BYPASS_COOKIE}=`);
                    // Exit early if bypassPrerender is set, so 'x-prerender-revalidate' header is not set,
                    // otherwise preview mode won't work.
                    if (bypassPrerender)
                        return;
                    // Allow the user to transform the request before it is sent to the Next SSR handler.
                    await ((_c = (_b = this.ssrOptions).transformRequest) === null || _c === void 0 ? void 0 : _c.call(_b, req));
                    // Force Next.js server to serve fresh page if any middleware isn't matched for this req
                    // and the prerender bypass cookie is not set.
                    // The 'x-prerender-revalidate' header is needed for ISG/ISR pages with revalidation when page is requested by the Edge,
                    // so Next.js knows it shouldn't serve page from disk or cache.
                    // Disadvantage is that if this header is present, Next.js server doesn't run the middlewares.
                    req.setHeader('x-prerender-revalidate', ((_d = this.manifestParser) === null || _d === void 0 ? void 0 : _d.getPreviewModeId()) || '');
                },
                transformResponse: async (response, request) => {
                    var _a, _b;
                    // Allow the user to transform the response before it is returned to the browser.
                    await ((_b = (_a = this.ssrOptions).transformResponse) === null || _b === void 0 ? void 0 : _b.call(_a, response, request));
                },
            });
        };
        this.nextRootDir = nextRootDir !== null && nextRootDir !== void 0 ? nextRootDir : (0, getNextRootDir_1.default)();
        this.edgioConfig = (0, config_1.getConfig)();
        this.nextConfig = (0, getNextConfig_1.default)(this.nextRootDir);
        this.distDir = (0, getDistDir_1.getDistDirFromConfig)(this.nextConfig);
        this.renderMode = (0, getRenderMode_1.default)(this.nextConfig);
        this.nextPathFormatter = new nextPathFormatter_1.default(this.nextConfig);
        // ManifestParser loads pages from the Next.js app
        // and collect all information about each of them.
        // The pages are loaded from manifest files in production mode
        // and from the pages and app folders in development mode. The pages in dev mode are all marked as SSR.
        this.manifestParser = new ManifestParser_1.default(this.nextRootDir, this.distDir, this.renderMode);
        this.pages = this.manifestParser.getPages();
        this.pagesMap = Object.fromEntries(this.pages.map(page => [page.name, page]));
        this.redirects = this.manifestParser.getRedirects();
        this.locales = this.manifestParser.getLocales();
        this.defaultLocale = this.manifestParser.getDefaultLocale();
        this.middlewares = this.manifestParser.getMiddlewares();
        // Production mode
        if ((0, environment_1.isProductionBuild)() || (0, environment_1.isCloud)()) {
            this.buildId = (0, getBuildId_1.default)((0, path_1.join)(this.nextRootDir, this.distDir));
        }
    }
    /**
     * Called when plugin is registered
     * @param router The router to which the plugin has been added.
     */
    onRegister(router) {
        var _a, _b, _c, _d, _e, _f;
        this.router = router;
        this.logDuringBuild(`> Next.js routes (locales: ${((_a = this.locales) === null || _a === void 0 ? void 0 : _a.join(', ')) || 'none'})`);
        this.logDuringBuild('');
        this.logPages();
        if (((_b = this.edgioConfig) === null || _b === void 0 ? void 0 : _b.proxyToServerlessByDefault) !== false &&
            ((_d = (_c = this.edgioConfig) === null || _c === void 0 ? void 0 : _c.next) === null || _d === void 0 ? void 0 : _d.proxyToServerlessByDefault) !== false) {
            this.addDefaultSSRRoute();
        }
        this.addPages();
        this.add404ErrorPages();
        this.addPrerenderedPages();
        if (((_f = (_e = this.edgioConfig) === null || _e === void 0 ? void 0 : _e.next) === null || _f === void 0 ? void 0 : _f.disablePreviewMode) !== true) {
            // Preview mode route needs to be added after prerendered pages
            // but before public assets, so it can be overridden by other rules.
            this.addPreviewModeRoute();
        }
        this.addPublicAssets();
        this.addAssets();
        this.addImageOptimizerRoutes();
        this.addRedirects();
        this.addServiceWorker();
        this.addPrerendering();
        this.logDuringBuild('');
        this.addImageOptimization();
        this.router.use(core_1.edgioRoutes);
    }
    /**
     * Adds rules for pre-rendered pages
     */
    addPrerenderedPages() {
        var _a, _b;
        let routes = [];
        let dataRoutes = [];
        this.pages.forEach(page => {
            var _a;
            return (_a = page === null || page === void 0 ? void 0 : page.prerenderedRoutes) === null || _a === void 0 ? void 0 : _a.forEach(({ nextRoute, route, dataRoute, initialRevalidateSeconds }) => {
                var _a;
                // Apply modifiers to route and data route
                nextRoute = this.addBasePath(nextRoute);
                route = this.addBasePath(route);
                dataRoute = this.addBasePath(dataRoute !== null && dataRoute !== void 0 ? dataRoute : '');
                // To reduce the number of generated rules, we will not use XBP for updating prerendered pages with revalidation on S3.
                // Instead, we will let Next.js handle them and return the stale-while-revalidate cache-control header with revalidation time.
                // These pages are then cached by the Edge for the specified time.
                // The only difference between these two approaches is in the first request or when page is fetching external data and it fails.
                // To achieve this, we will exclude these pages with revalidation from the rule with prerendered pages.
                if (page.hasRevalidation)
                    return;
                // When page is dynamic with params and has no data route,
                // we need to create a separate dynamic route because the IN operator can't be used with dynamic routes.
                // Example: /en-US/ssg/[id] => Path: /en-US/ssg/:id, Asset: /en-US/ssg/[id]/index.html
                if ((page === null || page === void 0 ? void 0 : page.isDynamic) && !(page === null || page === void 0 ? void 0 : page.dataRoute)) {
                    const routeAsset = `${constants_1.NEXT_PRERENDERED_PAGES_FOLDER}${nextRoute}/index.html`;
                    // We need to match both methods and path, because next 14 introduces server actions
                    // where on the same static path is server action sent but with different method (POST, PUT, DELETE, etc.)
                    (_a = this.router) === null || _a === void 0 ? void 0 : _a.if(
                    // NOTE: This could be simplified to IN operator { path: ['get', 'head'] },
                    // but that's for some reason not supported for request.method, and it throws 500 error during edge-control deployment.
                    (0, RouteCriteria_1.or)({ method: 'get' }, { method: 'head' }), ({ setComment }) => {
                        setComment('Serve pre-rendered page with dynamic route and no getStaticPaths');
                    }, new Router_1.default().match({ path: route }, ({ serveStatic, cache }) => {
                        serveStatic(routeAsset);
                        cache(cacheConfig_1.PUBLIC_CACHE_CONFIG);
                    }));
                    // Create separate rule
                    // No need to add data route, so we're done
                    return;
                }
                // Add to single rule
                routes.push(route);
                if (dataRoute)
                    dataRoutes.push(dataRoute);
            });
        });
        // We're done when we don't have any page routes
        if (routes.length === 0)
            return;
        // We need to add variations with trailing slash,
        // so the pages are always matched even when enforceTrailingSlash is disabled.
        routes = routes.flatMap(route => (route === '/' ? [route] : [route, `${route}/`]));
        // Match all pre-rendered routes with a single route handler.
        // We can do this only for pre-rendered pages because the "IN" operator doesn't work with dynamic routes.
        // We need to disable browser cache for all HTML pages so the user always
        // have the latest version of the page when app is redeployed.
        (_a = this.router) === null || _a === void 0 ? void 0 : _a.if(
        // NOTE: This could be simplified to IN operator { path: ['get', 'head'] },
        // but that's for some reason not supported for request.method, and it throws 500 error during edge-control deployment.
        (0, RouteCriteria_1.or)({ method: 'get' }, { method: 'head' }), ({ setComment }) => setComment('Serve all pre-rendered HTML pages (getStaticPaths)'), new Router_1.default().match({ path: routes }, ({ serveStatic, cache, removeRequestHeader }) => {
            serveStatic(`${constants_1.NEXT_PRERENDERED_PAGES_FOLDER}/:path*/index.html`);
            removeRequestHeader('if-modified-since');
            removeRequestHeader('if-none-match');
            cache(cacheConfig_1.PUBLIC_CACHE_CONFIG);
        }));
        // We're done when we don't have any data routes
        if (dataRoutes.length === 0)
            return;
        // Match all pre-rendered data routes with a single route handler.
        // Data routes contains buildId in the path, so we can cache it in browser.
        (_b = this.router) === null || _b === void 0 ? void 0 : _b.match({ path: dataRoutes }, ({ serveStatic, cache, setComment, removeRequestHeader }) => {
            setComment('Serve all pre-rendered JSON data files (getStaticPaths)');
            serveStatic(`${constants_1.NEXT_PRERENDERED_PAGES_FOLDER}/:path*`, {
                permanent: true,
            });
            removeRequestHeader('if-modified-since');
            removeRequestHeader('if-none-match');
            cache(cacheConfig_1.FAR_FUTURE_CACHE_CONFIG);
        });
    }
    /**
     * Adds rules with handler for all SSR, ISG, ISR pages
     */
    addPages() {
        this.pages.forEach(page => {
            var _a, _b, _c, _d, _e;
            // Skip pages which are pure SSG (addPrerenderedPages will handle them)
            if (page.type === types_1.PAGE_TYPES.ssg && !page.hasRevalidation)
                return;
            const routeHandlers = [];
            const dataRouteHandlers = [];
            // Add SSR handler to all pages when addDefaultSSRRoute was not added.
            // This will generate a separate rule for all not pre-rendered pages.
            if (((_b = (_a = this.edgioConfig) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.proxyToServerlessByDefault) === false ||
                ((_c = this.edgioConfig) === null || _c === void 0 ? void 0 : _c.proxyToServerlessByDefault) === false) {
                routeHandlers.push(this.ssrHandler);
                dataRouteHandlers.push(this.ssrHandler);
            }
            // Add request header with page name to all pages except SSG.
            // This is used to determine which page is being rendered in serverless mode
            // when request reaches serverless origin.
            // To not generate extensive amount of routes, we add this header only in serverless mode.
            if (this.renderMode === types_1.RENDER_MODES.serverless) {
                routeHandlers.push(routeHelper => (0, setNextPage_1.default)(page.name, routeHelper));
                dataRouteHandlers.push(routeHelper => (0, setNextPage_1.default)(page.name, routeHelper));
            }
            // This ensures that we will have all features for one route in one rule
            // instead of having multiple rules for one route.
            // Add rule with all route handlers for route.
            if (routeHandlers.length > 0) {
                (_d = this.router) === null || _d === void 0 ? void 0 : _d.match(this.addBasePath(page.localizedRoute), routeHelper => {
                    routeHandlers.forEach(handler => handler(routeHelper));
                });
            }
            // Add rule with all route handlers for data route.
            if (dataRouteHandlers.length > 0 && (page === null || page === void 0 ? void 0 : page.localizedDataRoute)) {
                (_e = this.router) === null || _e === void 0 ? void 0 : _e.match(this.addBasePath(page.localizedDataRoute), routeHelper => {
                    dataRouteHandlers.forEach(handler => handler(routeHelper));
                });
            }
        });
    }
    /**
     * Adds rules which serves static HTML 404 error page
     * for all not prerendered routes which has fallback: false.
     */
    add404ErrorPages() {
        this.pages.forEach(page => {
            var _a, _b, _c, _d, _e, _f, _g;
            // We will add 404 error page just for pages with fallback: false
            if ((page === null || page === void 0 ? void 0 : page.fallback) !== types_1.FALLBACK_TYPES.false)
                return;
            const assetPath = constants_1.NEXT_PRERENDERED_PAGES_FOLDER +
                this.addBasePath(`/${this.locales.length > 0 ? ':locale/' : ''}`);
            // Because the rules are overlapping and the features of matched rules are then merged together,
            // we need to exclude all pre-rendered routes from the 404 error page rule with dynamic path.
            (_a = this.router) === null || _a === void 0 ? void 0 : _a.if((0, RouteCriteria_1.and)({
                path: this.addBasePath(page.localizedRoute),
            }, {
                path: {
                    not: (_d = (_c = (_b = page.prerenderedRoutes) === null || _b === void 0 ? void 0 : _b.map(({ route }) => this.addBasePath(route))) === null || _c === void 0 ? void 0 : _c.flatMap(route => (route === '/' ? [route] : [route, `${route}/`]))) !== null && _d !== void 0 ? _d : [],
                },
            }), ({ setComment, serveStatic, cache, setResponseCode }) => {
                // Serve static 404 error page for all not pre-rendered routes.
                setComment('Serve 404 for HTML paths not returned by getStaticPaths (fallback: false)');
                serveStatic(`${assetPath}/404/index.html`.replace(/\/+/g, '/'), {
                    rewritePathSource: this.addBasePath(page.localizedRoute),
                });
                // Overrides default cache config from serveStatic
                cache({
                    ...cacheConfig_1.PUBLIC_CACHE_CONFIG,
                    cacheableStatusCodes: [404],
                });
                setResponseCode(404);
            });
            // We're done if there is no data route
            if (!(page === null || page === void 0 ? void 0 : page.localizedDataRoute))
                return;
            (_e = this.router) === null || _e === void 0 ? void 0 : _e.if((0, RouteCriteria_1.and)({
                path: this.addBasePath(page.localizedDataRoute),
            }, {
                path: {
                    not: (_g = (_f = page.prerenderedRoutes) === null || _f === void 0 ? void 0 : _f.map(({ dataRoute }) => this.addBasePath(dataRoute !== null && dataRoute !== void 0 ? dataRoute : ''))) !== null && _g !== void 0 ? _g : [],
                },
            }), ({ setComment, setResponseCode }) => {
                // We want to serve HTML error page even for not prerendered data route
                setComment('Serve 404 for JSON paths not returned by getStaticPaths (fallback: false)');
                setResponseCode(404);
            });
        });
    }
    /**
     * Logs provided route with label and other params
     * to the console during the build.
     * @param page
     * @param route
     * @param label
     * @param initialRevalidateSeconds
     * @returns
     */
    logRoute(page, route, label, initialRevalidateSeconds) {
        var _a, _b;
        const parameters = [];
        if (page.fallback) {
            parameters.push(chalk_1.default.grey(`${page.fallback}`));
        }
        initialRevalidateSeconds =
            initialRevalidateSeconds || ((_b = (_a = page === null || page === void 0 ? void 0 : page.prerenderedRoutes) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.initialRevalidateSeconds);
        if (initialRevalidateSeconds) {
            parameters.push(chalk_1.default.grey(`revalidate: ${initialRevalidateSeconds}`));
        }
        const type = `${page.type}${label ? ' ' + label : ''}`;
        const params = parameters.length > 0 ? chalk_1.default.grey(` (${parameters.join(', ')})`) : '';
        this.logDuringBuild(`  ${chalk_1.default.blueBright(type)}${params}: ${route}`);
    }
    /**
     * Logs a pages with their data routes
     * and prerendered routes to the console during the build.
     * @returns
     */
    logPages() {
        this.pages.forEach(page => {
            var _a;
            // Skip SSG pages from logging here to not log them twice.
            // They are logged as prerendered routes.
            if (page.type !== types_1.PAGE_TYPES.ssg) {
                // Log route of page without data route
                if (!page.dataRoute || !page.localizedDataRoute)
                    return this.logRoute(page, this.addBasePath(page.localizedRoute), '');
                // Log routes of page with data route
                this.logRoute(page, this.addBasePath(page.localizedRoute), 'html');
                this.logRoute(page, this.addBasePath(page.localizedDataRoute), 'json');
            }
            // Log prerendered routes of page
            (_a = page.prerenderedRoutes) === null || _a === void 0 ? void 0 : _a.forEach(({ route, dataRoute, initialRevalidateSeconds }) => {
                this.logRoute(page, this.addBasePath(route), 'html', initialRevalidateSeconds);
                if (dataRoute)
                    this.logRoute(page, this.addBasePath(dataRoute), 'json', initialRevalidateSeconds);
            });
        });
    }
    /**
     * Outputs a message to the console during the build.
     * @param message
     * @returns
     */
    logDuringBuild(message) {
        if ((0, environment_1.isProductionBuild)() && !(0, environment_1.isCloud)())
            console.log(message);
    }
    /**
     * Adds redirects from next.config.js
     */
    addRedirects() {
        var _a, _b, _c;
        if (!this.redirects)
            return;
        for (let { source, has, statusCode, destination, internal, locale } of this.redirects) {
            if (this.defaultLocale && locale !== false) {
                // Next.js server is performing redirect for paths with and without default locale.
                // We adjust redirects which start with default locale here, to make sure that they are working the same way.
                source = source.replace(`/${this.defaultLocale}/`, `/:nextInternalLocale(${this.defaultLocale})?/`);
            }
            // next < 10 did not have the internal property
            const isInternalRedirect = internal || source === '/:path+/';
            let criteria = this.createRouteCriteria(source, has);
            statusCode = statusCode || 302;
            // Do not add internal redirects if enforceTrailingSlash is disabled
            if (isInternalRedirect && ((_b = (_a = this.edgioConfig) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.enforceTrailingSlash) === false)
                continue;
            (_c = this.router) === null || _c === void 0 ? void 0 : _c.match(criteria, ({ setComment, setResponseCode, addFeatures, rewritePath, redirect }) => {
                if (isInternalRedirect) {
                    // For Next's internal redirects, which either add or remove the trailing slash, depending on the value of the trailingSlash config,
                    // we need to ensure that the route matches the entire path or these redirects will cause an infinite loop.
                    // These internal redirects don't have valid path-to-regex syntax used by edge-control.
                    // That's why we need to convert them to actual regex.
                    setComment("Next's internal redirect");
                    addFeatures({
                        url: {
                            url_redirect: {
                                code: statusCode,
                                syntax: 'regexp',
                                source: (0, toEdgeRegex_1.default)(new RegExp((0, path_to_regexp_1.pathToRegexp)(source))),
                                destination: (0, bindParams_1.default)(destination, (0, path_2.getBackReferences)(source)),
                            },
                        },
                    });
                    // We need to add this empty rewrite to delete any previous rewrites.
                    // Otherwise, the redirect will not match the URL.
                    rewritePath('/:path*', '/:path*');
                }
                else if ((0, path_2.isAbsoluteUrl)(destination)) {
                    // When absolute URL is provided, we need to use Regex syntax,
                    // as using path-to-regexp would not work with absolute URLs.
                    // This is also more aligned with UI rule builder.
                    addFeatures({
                        url: {
                            url_redirect: {
                                code: statusCode,
                                syntax: 'regexp',
                                source: (0, toEdgeRegex_1.default)(new RegExp((0, path_to_regexp_1.pathToRegexp)(source))),
                                destination: (0, bindParams_1.default)(destination, (0, path_2.getBackReferences)(source)),
                            },
                        },
                    });
                }
                else {
                    redirect(destination, { statusCode: statusCode });
                }
                setResponseCode(statusCode);
            });
            this.logDuringBuild(`  ${chalk_1.default.blueBright('redirect')}: ${typeof criteria === 'object' && !(criteria instanceof RegExp)
                ? JSON.stringify(criteria)
                : criteria === null || criteria === void 0 ? void 0 : criteria.toString()} => ${destination}`);
        }
    }
    /**
     * Creates a Edgio RouteCriteria from path and has attributes found in rewrites in redirects
     * in next.config.js.
     * @param path The path pattern
     * @param has Has elements from next.config.js rewrites and redirects.
     * @returns
     */
    createRouteCriteria(path, has) {
        if (has) {
            let headers = {};
            let cookies = {};
            let query = {};
            for (let el of has) {
                if (typeof el.value === 'string' && el.value.match(/\(\?<[^>]+>/)) {
                    throw new Error('Edgio does not yet support capturing named parameters in `has` elements of `redirects` in next.config.js.');
                }
                if (el.type === 'header') {
                    headers[el.key] = el.value ? new RegExp(el.value) : /.*/;
                }
                else if (el.type === 'host') {
                    headers.host = new RegExp(el.value);
                }
                else if (el.type === 'cookie') {
                    cookies[el.key] = el.value ? new RegExp(el.value) : /.*/;
                }
                else if (el.type === 'query') {
                    query[el.key] = el.value ? new RegExp(el.value) : /.*/;
                }
                else {
                    console.warn(`Warning: has.type ${el.type} is not supported by Edgio`);
                }
            }
            return {
                path,
                headers: Object.keys(headers).length ? headers : undefined,
                cookies: Object.keys(cookies).length ? cookies : undefined,
                query: Object.keys(query).length ? query : undefined,
            };
        }
        else {
            return path;
        }
    }
    /**
     * Adds routes for static assets in /public
     */
    addPublicAssets() {
        var _a;
        (_a = this.router) === null || _a === void 0 ? void 0 : _a.static('public', {
            handler: ({ cache, setComment }) => {
                setComment('Serve all assets from public/ folder');
                cache(cacheConfig_1.SHORT_PUBLIC_CACHE_CONFIG);
            },
        });
    }
    /**
     * Adds routes for static assets of /.next/static
     */
    addAssets() {
        var _a, _b, _c;
        if (!(0, environment_1.isCloud)())
            (_a = this.router) === null || _a === void 0 ? void 0 : _a.match(this.addBasePath('/_next/webpack-hmr'), this.ssrHandler);
        const staticHandler = ({ serveStatic, cache }) => {
            serveStatic(`${this.distDir}/static/:path*`, {
                permanent: true,
            });
            // These files have unique names,
            // so we can cache them for a long time
            cache(cacheConfig_1.FAR_FUTURE_CACHE_CONFIG);
        };
        const handler = (0, environment_1.isCloud)() || (0, environment_1.isProductionBuild)() ? staticHandler : this.ssrHandler;
        // browser js
        // Notes:
        // - Assets with unique hashed filenames like JS, Css, and media are stored
        //   in a persistent bucket to be available across builds
        // - We can't apply that rule to the whole /static folder as it contains
        //   non-unique filenames like 'service-worker.js'. This will
        (_b = this.router) === null || _b === void 0 ? void 0 : _b.match(this.addBasePath('/_next/static/:path*'), handler);
        (_c = this.router) === null || _c === void 0 ? void 0 : _c.match(this.addBasePath('/autostatic/:path*'), handler);
    }
    /**
     * Adds route for preview mode,
     * that bypasses cache, overrides origin for pre-rendered pages
     * and sets it to serverless when "__bypass-prerender" and "__preview_data" cookies are present.
     */
    addPreviewModeRoute() {
        var _a;
        (_a = this.router) === null || _a === void 0 ? void 0 : _a.match({
            cookies: {
                [constants_1.NEXT_PRERENDER_BYPASS_COOKIE]: /(.+)/,
                [constants_1.NEXT_PREVIEW_DATA_COOKIE]: /(.+)/,
            },
        }, routeHelper => {
            const { cache, setComment, setResponseHeader, rewritePath } = routeHelper;
            this.ssrHandler(routeHelper);
            setComment('Bypass cache and pre-rendered pages with preview mode');
            cache({
                // Disable cache for preview mode,
                // so the user immediately sees the changes.
                edge: false,
                browser: false,
            });
            // Override previously matched rewrites
            rewritePath('/:path*', '/:path*');
            // Indicate that the preview mode is enabled,
            // so users are not surprised they don't see cache hits.
            setResponseHeader('x-preview-mode', 'true');
        });
    }
    /**
     * Adds rule that enables image optimization for supported image types.
     */
    addImageOptimization() {
        var _a;
        // NOTE: This is quick fix for bug in Sailfish, as it removes encoding-type when image optimization is enabled.
        // With this fix the image optimization will remain the same but as we are setting the rule only for images
        // it won't affect other static files (like fonts, css, json, etc.)
        // Important thing is that SVG is not in the list of supported image types,
        // otherwise sailfish throws 500 error.
        (_a = this.router) === null || _a === void 0 ? void 0 : _a.match(/\.(jpg|jpeg|pjpg|pjpeg|png|ppng|gif|bmp|webp|ico|tif|tiff|jfif|jp2|j2k|jpf|jpx|jpm|mj2|xbm|wbmp)$/, ({ optimizeImages, setComment }) => {
            setComment('Generic image optimization rule for all image types.');
            optimizeImages(true);
        });
    }
    /**
     * Adds routes for Image Optimizer:
     * - Edgio Image Proxy
     * - Next Image Optimizer
     */
    addImageOptimizerRoutes() {
        var _a, _b, _c, _d;
        // We also need to add rule for Next's image-optimizer
        // when app is running in development mode
        // just for case when proxyToServerlessByDefault is false.
        if (((_b = (_a = this.edgioConfig) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.disableImageOptimizer) || !(0, environment_1.isProductionBuild)()) {
            this.addNextImageOptimizerRoutes();
        }
        if (!((_d = (_c = this.edgioConfig) === null || _c === void 0 ? void 0 : _c.next) === null || _d === void 0 ? void 0 : _d.disableImageOptimizer)) {
            this.addEdgioImageProxyRoutes();
        }
    }
    /**
     * Adds route for next image-optimizer when app run in production mode
     */
    addNextImageOptimizerRoutes() {
        var _a;
        // We need to transform relative image paths to absolute to force next/image optimizer in server built to fully work
        // because images are not on local file system but on S3.
        // This route is used when our sailfish's image optimizer is disabled
        // or when user wants to optimize images on remote hosts.
        (_a = this.router) === null || _a === void 0 ? void 0 : _a.match(this.addBasePath('/_next/(image|future/image)'), ({ proxy, cache, setComment }) => {
            setComment('Next Image Optimizer');
            cache(cacheConfig_1.SHORT_PUBLIC_CACHE_CONFIG);
            proxy(origins_1.SERVERLESS_ORIGIN_NAME, {
                transformRequest: req => {
                    const protocol = req.secure ? 'https://' : 'http://';
                    // The request will be proxied to the same host on local
                    // Deployed app will use permalink host from EDGIO_PERMALINK_HOST env variable
                    const hostname = process.env.EDGIO_PERMALINK_HOST ||
                        process.env.EDGIO_IMAGE_OPTIMIZER_HOST ||
                        req.headers.host;
                    const url = new URL(req.url, `${protocol}${hostname}`);
                    const imgUrl = url.searchParams.get('url');
                    // ignore absolute paths
                    if (!imgUrl || imgUrl.startsWith('http'))
                        return;
                    url.searchParams.set('url', `${protocol}${hostname}${imgUrl}`);
                    req.url = `${url.pathname}?${url.searchParams.toString()}`;
                },
            });
        });
    }
    /**
     * Adds route that will proxy images from remote hosts,
     * so they can be later optimized by Sailfish's image-optimizer,
     * and cached on the edge. This approach works even with old serverless builds
     * without Next's image-optimizer. This rule is used by our imageLoader.
     */
    addEdgioImageProxyRoutes() {
        var _a;
        // This feature proxies images from remote hosts
        const imageProxyFeature = ({ compute, cache, setComment }) => {
            setComment('Edgio Image Proxy - Proxies images from remote hosts');
            cache(cacheConfig_1.SHORT_PUBLIC_CACHE_CONFIG);
            compute(async (req, res) => {
                try {
                    const url = new URL(req.url, `http://${req.headers['host']}`);
                    const imgUrl = url.searchParams.get('url');
                    if (!imgUrl || !(0, isValidRemotePattern_1.default)(this.nextConfig, imgUrl)) {
                        res.statusCode = 400;
                        res.statusMessage = 'Bad Request';
                        res.body = `ERROR: The provided URL is not defined in 'next.config.js' under 'images.remotePatterns' or 'images.domains'.`;
                        if ((0, environment_1.isLocal)()) {
                            console.error(`[Edgio] Image Proxy ERROR: The provided URL is not allowed.\r\n` +
                                `Please add the URL to 'next.config.js' under 'images.remotePatterns' or 'images.domains'.\r\n` +
                                `See https://nextjs.org/docs/pages/api-reference/components/image#remotepatterns for more details.\r\n` +
                                `URL: ${imgUrl}\r\n`);
                        }
                        return;
                    }
                    // Standard fetch func is returning arrayBuffer,
                    // so we need to convert it to Buffer from Node.js here.
                    const remoteRes = await fetch(imgUrl);
                    // Allow to proxy only images.
                    // We have localhost and 127.0.0.1 in allowed domains by default,
                    // and this would allow to expose potentially sensitive data from customer's app.
                    const contentType = remoteRes.headers.get(core_1.HTTP_HEADERS.contentType);
                    if (!(contentType === null || contentType === void 0 ? void 0 : contentType.startsWith('image'))) {
                        res.statusCode = 400;
                        res.body = `ERROR: The requested asset on given URL is not an image.`;
                        console.error(`[Edgio] Image Proxy ERROR: The requested asset on given URL is not an image.`);
                        return;
                    }
                    // Copy required headers from the remote response to the response
                    // NOTE: Do not content-encoding header, because the response is already encoded
                    // by @edgio/core with brotli or gzip, and it sets the correct content-encoding header.
                    remoteRes.headers.forEach((value, name) => {
                        if (![core_1.HTTP_HEADERS.contentLength, core_1.HTTP_HEADERS.contentType].includes(name.toLowerCase()))
                            return;
                        res.setHeader(name, value);
                    });
                    // Write the body of the response
                    res.body = Buffer.from(await remoteRes.arrayBuffer());
                }
                catch (e) {
                    res.statusCode = 500;
                    res.body = `ERROR: Couldn't fetch the image from the provided URL.`;
                    console.error(`[Edgio] Image Proxy ERROR: ${e.message}`);
                }
            });
        };
        // This feature enables image optimization only for supported image types.
        // NOTE: We need to use nested rule here, because console-ui can't
        // currently display AND operator inside OR operator,
        // and switches to JSON editor, although it's valid edge-control syntax.
        const optimizeImagesFeature = new Router_1.default().match({
            query: {
                url: /\.(jpg|jpeg|pjpg|pjpeg|png|ppng|gif|bmp|webp|ico|tif|tiff|jfif|jp2|j2k|jpf|jpx|jpm|mj2|xbm|wbmp)$/i,
            },
        }, ({ optimizeImages }) => {
            optimizeImages(true);
        });
        // Put both features into one rule
        (_a = this.router) === null || _a === void 0 ? void 0 : _a.if({
            path: constants_1.EDGIO_IMAGE_PROXY_PATH,
        }, imageProxyFeature, optimizeImagesFeature);
    }
    /**
     * Adds route with service worker file.
     * This route is used in both production and development modes.
     */
    addServiceWorker() {
        var _a, _b, _c;
        if ((_b = (_a = this.edgioConfig) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.disableServiceWorker)
            return;
        (_c = this.router) === null || _c === void 0 ? void 0 : _c.match(`/${constants_1.SERVICE_WORKER_FILENAME}`, ({ serviceWorker }) => {
            serviceWorker(); // We don't provide a path here because the build process puts it in the correct path (s3/service-worker.js)
        });
    }
    /**
     * By default, we send all requests to Next SSR running in serverless.
     * Subsequent static routes will overwrite this and use either edgio_serverless or edgio_serverless_static origins.
     */
    addDefaultSSRRoute() {
        var _a;
        (_a = this.router) === null || _a === void 0 ? void 0 : _a.match('/(.*)', routeHelper => {
            routeHelper.setComment('Send all requests to Next SSR running in serverless by default');
            this.ssrHandler(routeHelper);
        });
    }
    /**
     * Sets the SSR handler options that will be used when proxying requests to the Next SSR handler in serverless mode.
     */
    setSSROptions(options) {
        this.ssrOptions = options;
        return this;
    }
    /**
     * Adds prerendering to pull all SSG pages into the edge cache.
     */
    addPrerendering() {
        var _a;
        const requests = [];
        this.pages.forEach(page => {
            var _a;
            // We want to skip SSG pages which are pre-rendered but have dynamic route.
            // Example: /dynamic/ssg/[id]
            if ((page === null || page === void 0 ? void 0 : page.isDynamic) && (page === null || page === void 0 ? void 0 : page.type) === types_1.PAGE_TYPES.ssg)
                return;
            (_a = page === null || page === void 0 ? void 0 : page.prerenderedRoutes) === null || _a === void 0 ? void 0 : _a.forEach(({ route, dataRoute }) => {
                requests.push({ path: this.addBasePath(route) });
                if (dataRoute)
                    requests.push({ path: this.addBasePath(dataRoute) });
            });
        });
        (_a = this.router) === null || _a === void 0 ? void 0 : _a.prerender(requests);
    }
    /**
     * This method is executed before the request is proxied to Next.js in serverless mode.
     * It adds the page params to the query string, so they are correctly parsed under req.params.
     * Without this function the params under context.params would be empty
     * and only available under req.query on SSR pages.
     * @param req
     */
    addPageParamsToQuery(req) {
        const pageName = `/${req.getHeaders()[constants_1.NEXT_PAGE_HEADER] || '404'}`;
        const page = this.pagesMap[pageName];
        if (!pageName || !page)
            return;
        // Try to extract params from the path based on provided page route
        const pageRouteParams = new ParamsExtractor_1.default({
            path: page.localizedRoute,
        }).extract(req);
        // Try to extract params from the path based on provided page data route
        const pageDataRouteParams = new ParamsExtractor_1.default({
            path: page.localizedDataRoute,
        }).extract(req);
        // Override existing query params with same name
        req.query = { ...req.query, ...pageRouteParams, ...pageDataRouteParams };
        let searchParams = qs_1.default.stringify(req.query, {
            // Instead of stringifying duplicates as color[0]=red&color[1]=blue
            // we want to preserve duplicate query param names: color=red&color=blue
            // so the params are always parsed as an array by next.
            indices: false,
        });
        req.url = `${req.path}${searchParams.length ? '?' : ''}${searchParams}`;
    }
    /**
     * Adds leading basePath property from next.config.js to path
     * in case it's specified
     * @param path
     */
    addBasePath(path) {
        var _a;
        if (!((_a = this.nextConfig) === null || _a === void 0 ? void 0 : _a.basePath))
            return path;
        if (path === '/' && !this.nextConfig.trailingSlash)
            return this.nextConfig.basePath;
        return `${this.nextConfig.basePath}${path}`.replace('//', '/');
    }
    /**
     * Set this option to true to honor Next's internal redirects that either add or remove a trailing slash
     * depending on the value of the `trailingSlash` config. When set to false, these internal redirects are not honored,
     * so sites that fallback to serving from an origin do not add or remove the trailing slash for origin URLs.
     * @param value
     * @deprecated
     */
    setEnforceTrailingSlash(value) {
        var _a;
        console.warn(`[Edgio] ${chalk_1.default.yellow("Warning: The 'setEnforceTrailingSlash' method is deprecated. This config option was moved to 'edgio.config.js'.")}`);
        if (!((_a = this.edgioConfig) === null || _a === void 0 ? void 0 : _a.next))
            this.edgioConfig.next = {};
        this.edgioConfig.next.enforceTrailingSlash = value;
        return this;
    }
}
exports.default = NextRoutes;
