"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@edgio/core/utils");
const path_1 = require("path");
const fs_1 = require("@edgio/core/utils/fs");
const nextPathFormatter_1 = __importDefault(require("./nextPathFormatter"));
const getNextConfig_1 = __importDefault(require("../getNextConfig"));
const localeUtils_1 = require("../util/localeUtils");
const path_to_regexp_1 = require("path-to-regexp");
const types_1 = require("../types");
const environment_1 = require("@edgio/core/environment");
const getBuildId_1 = __importDefault(require("../util/getBuildId"));
const globby_1 = __importDefault(require("globby"));
const getPageExtensions_1 = require("../util/getPageExtensions");
class ManifestParser {
    /**
     * @param nextRootDir The path to project root
     * @param distDir The name of dist folder
     * @param renderMode The render mode
     */
    constructor(nextRootDir, distDir, renderMode) {
        var _a, _b, _c, _d;
        this.pagesManifest = {};
        this.appPathsManifest = {};
        this.pageFiles = {};
        this.locales = [];
        this.buildId = 'dev';
        this.nextRootDir = nextRootDir;
        this.distDir = distDir;
        this.renderMode = renderMode;
        this.nextConfig = (0, getNextConfig_1.default)(nextRootDir);
        this.nextPathFormatter = new nextPathFormatter_1.default(this.nextConfig);
        this.locales = ((_b = (_a = this.nextConfig) === null || _a === void 0 ? void 0 : _a.i18n) === null || _b === void 0 ? void 0 : _b.locales) || [];
        this.defaultLocale = (_d = (_c = this.nextConfig) === null || _c === void 0 ? void 0 : _c.i18n) === null || _d === void 0 ? void 0 : _d.defaultLocale;
        this.pagesDir = (0, fs_1.existsSync)((0, path_1.join)(this.nextRootDir, 'src', 'pages'))
            ? (0, path_1.join)(this.nextRootDir, 'src', 'pages')
            : (0, path_1.join)(this.nextRootDir, 'pages');
        this.appDir = (0, fs_1.existsSync)((0, path_1.join)(this.nextRootDir, 'src', 'app'))
            ? (0, path_1.join)(this.nextRootDir, 'src', 'app')
            : (0, path_1.join)(this.nextRootDir, 'app');
        // Exit when we are in development mode
        if (!(0, environment_1.isProductionBuild)() && !(0, environment_1.isCloud)())
            return;
        this.buildId = (0, getBuildId_1.default)((0, path_1.join)(this.nextRootDir, this.distDir));
        this.routesManifest = this.getRoutesManifest();
        this.prerenderManifest = this.getPrerenderManifest();
        this.middlewareManifest = this.getMiddlewareManifest();
        this.pagesManifest = this.getPagesManifest();
        this.appPathsManifest = this.getAppPathsManifest();
        this.pageFiles = { ...this.pagesManifest, ...this.appPathsManifest };
    }
    /**
     * Returns the objects of parsed pages
     * @param includeTemplates
     */
    getPages(includeTemplates = false) {
        if ((0, environment_1.isProductionBuild)() || (0, environment_1.isCloud)()) {
            return this.getPagesInProd(includeTemplates);
        }
        return this.getPagesInDev(includeTemplates);
    }
    /**
     * Returns the objects of parsed extracted from
     * the pages and app directory because there is no manifest file.
     * Pages in development mode are not pre-rendered and all marked as SSR.
     * @param includeTemplates
     */
    getPagesInDev(includeTemplates = false) {
        let pages = [];
        const pageExtensions = (0, getPageExtensions_1.getPageExtensionsFromConfig)(this.nextConfig);
        // Get page routes from pages directory
        globby_1.default.sync(`**/*.{${pageExtensions.join(',')}}`, { cwd: this.pagesDir }).forEach(file => {
            const pageName = this.nextPathFormatter.toCleanPath(file);
            if (!includeTemplates && this.isTemplate(pageName))
                return;
            pages.push({
                name: pageName,
                nameWithoutLocale: pageName,
                ...this.nextPathFormatter.getRouteVariations(pageName, {
                    locales: this.locales,
                }),
                type: types_1.PAGE_TYPES.ssr,
                pageSource: types_1.PAGE_SOURCE_TYPES.pages,
            });
        });
        // Get page routes from app directory
        globby_1.default.sync(`**/page.{${pageExtensions.join(',')}}`, { cwd: this.appDir }).forEach(file => {
            const pageName = this.nextPathFormatter.toCleanPath(`/${file}`.replace('/page', ''));
            pages.push({
                name: pageName,
                nameWithoutLocale: pageName,
                ...this.nextPathFormatter.getRouteVariations(pageName, {
                    locales: this.locales,
                }),
                type: types_1.PAGE_TYPES.ssr,
                pageSource: types_1.PAGE_SOURCE_TYPES.app,
            });
        });
        return pages;
    }
    /**
     * Returns the objects of parsed pages
     * extracted from the manifest files.
     * @param includeTemplates
     */
    getPagesInProd(includeTemplates = false) {
        var _a;
        let pages = [];
        for (const pageName in this.pageFiles) {
            if (!includeTemplates && this.isTemplate(pageName))
                continue;
            const pageNameWithoutLocale = (0, localeUtils_1.removeLocale)(pageName, this.locales);
            const dataRouteData = this.getDataRoute(pageName);
            const { route, localizedRoute, dataRoute, localizedDataRoute } = this.nextPathFormatter.getRouteVariations(pageName, {
                locales: this.locales,
            });
            let page = {
                name: pageName,
                nameWithoutLocale: pageNameWithoutLocale,
                route,
                localizedRoute,
                isPrerendered: this.isPrerendered(pageName),
                isDynamic: this.isDynamic(pageNameWithoutLocale),
            };
            if (dataRouteData) {
                page.dataRoute = dataRoute;
                page.localizedDataRoute = localizedDataRoute;
            }
            if (page === null || page === void 0 ? void 0 : page.isPrerendered) {
                page.fallback = this.getFallbackType(pageName);
            }
            if ((page === null || page === void 0 ? void 0 : page.fallback) === types_1.FALLBACK_TYPES.true) {
                page.fallbackPage = this.getFallback(pageName);
            }
            if (page === null || page === void 0 ? void 0 : page.isPrerendered) {
                page.prerenderedRoutes = this.getPrerenderedRoutes(page);
            }
            page.hasRevalidation = (_a = page === null || page === void 0 ? void 0 : page.prerenderedRoutes) === null || _a === void 0 ? void 0 : _a.some(({ initialRevalidateSeconds }) => initialRevalidateSeconds);
            page.type = this.getPageType(page);
            page.pageSource = this.getPageSourceType(pageName);
            pages.push(page);
        }
        return this.sortPages(pages);
    }
    /**
     * Attempt to get redirects from routes-manifest.json in production
     * and from next.config.js in development.
     */
    getRedirects() {
        var _a, _b;
        let redirects = (0, environment_1.isProductionBuild)() || (0, environment_1.isCloud)() ? (_a = this.routesManifest) === null || _a === void 0 ? void 0 : _a.redirects : (_b = this.nextConfig) === null || _b === void 0 ? void 0 : _b.redirects;
        return Array.isArray(redirects) ? redirects : [];
    }
    /**
     * Returns middlewares from middleware-manifest.json
     */
    getMiddlewares() {
        var _a;
        return Object.values(((_a = this.middlewareManifest) === null || _a === void 0 ? void 0 : _a.middleware) || {});
    }
    /**
     * Returns page type based on it's properties
     * @param page
     */
    getPageType(page) {
        const hasFileWithHtmlExtension = this.hasFileWithHtmlExtension(page.name);
        if (this.isTemplate(page.name))
            return types_1.PAGE_TYPES.template;
        if (page.name.startsWith('/api'))
            return types_1.PAGE_TYPES.api;
        if (page.isPrerendered && page.isDynamic && !hasFileWithHtmlExtension && !page.hasRevalidation)
            return types_1.PAGE_TYPES.isg;
        if (page.isPrerendered && page.isDynamic && !hasFileWithHtmlExtension && page.hasRevalidation)
            return types_1.PAGE_TYPES.isr;
        if (page.isPrerendered)
            return types_1.PAGE_TYPES.ssg;
        return types_1.PAGE_TYPES.ssr;
    }
    /**
     * Returns fallback type based on value from dynamicRoutes.
     * @param pageName
     */
    getFallbackType(pageName) {
        const fallback = this.getFallback(pageName);
        if (fallback === null)
            return types_1.FALLBACK_TYPES.blocking;
        if (typeof fallback === 'string')
            return types_1.FALLBACK_TYPES.true;
        if (fallback === false)
            return types_1.FALLBACK_TYPES.false;
        return undefined;
    }
    /**
     * Returns page source type. Can be located in 'app' or 'pages' folder.
     * @param pageName
     */
    getPageSourceType(pageName) {
        if (this.pagesManifest[pageName])
            return types_1.PAGE_SOURCE_TYPES.pages;
        if (this.appPathsManifest[pageName])
            return types_1.PAGE_SOURCE_TYPES.app;
        return undefined;
    }
    /**
     * Returns the contents of routes-manifest.json
     */
    getRoutesManifest() {
        const routesManifestPath = process.env.NEXT_ROUTES_MANIFEST_PATH ||
            (0, path_1.join)(this.nextRootDir, this.distDir, 'routes-manifest.json');
        if (!(0, fs_1.existsSync)(routesManifestPath))
            return undefined;
        return (0, utils_1.nonWebpackRequire)(routesManifestPath);
    }
    /**
     * Returns the contents of pages-manifest.json
     */
    getPagesManifest() {
        const pagesManifestPath = (0, path_1.join)(this.nextRootDir, this.distDir, this.renderMode, 'pages-manifest.json');
        if (!(0, fs_1.existsSync)(pagesManifestPath))
            return {};
        return (0, utils_1.nonWebpackRequire)(pagesManifestPath);
    }
    /**
     * Returns the content of app-paths-manifest.json
     * and changes the format of keys to correct URLs
     */
    getAppPathsManifest() {
        const location = (0, path_1.join)(this.nextRootDir, this.distDir, this.renderMode, 'app-paths-manifest.json');
        if (!(0, fs_1.existsSync)(location))
            return {};
        const appPaths = (0, utils_1.nonWebpackRequire)(location);
        let appPathsOutput = {};
        // Removes the /page from path
        Object.keys(appPaths).forEach((key) => {
            let editedPath = key.substring(0, key.lastIndexOf('/page'));
            editedPath = editedPath.length === 0 ? '/' : editedPath;
            appPathsOutput = {
                ...appPathsOutput,
                [editedPath]: appPaths[key],
            };
        });
        return appPathsOutput;
    }
    /**
     * Returns the contents of middleware-manifest.json
     */
    getMiddlewareManifest() {
        const path = (0, path_1.join)(this.nextRootDir, this.distDir, this.renderMode, 'middleware-manifest.json');
        if ((0, fs_1.existsSync)(path))
            return (0, utils_1.nonWebpackRequire)(path);
        return {
            sortedMiddleware: [],
            middleware: {},
        };
    }
    /**
     * Returns the contents of prerender-manifest.json
     */
    getPrerenderManifest() {
        const path = (0, path_1.join)(this.nextRootDir, this.distDir, 'prerender-manifest.json');
        try {
            return (0, utils_1.nonWebpackRequire)(path);
        }
        catch (e) {
            if (process.env.DEBUG === 'true')
                console.log(`${path} not found`);
            return {
                routes: {},
                dynamicRoutes: {},
                notFoundRoutes: [],
            };
        }
    }
    /**
     * Returns true if page path is dynamic
     * @param pageNameWithoutLocale
     */
    isDynamic(pageNameWithoutLocale) {
        var _a;
        return (((_a = this.routesManifest) === null || _a === void 0 ? void 0 : _a.dynamicRoutes.find((r) => r.page === pageNameWithoutLocale)) !==
            undefined);
    }
    /**
     * Returns true if the specified page was statically rendered at build time (no getServerSideProps or getInitialProps)
     * @param page The page key
     * @returns
     */
    isPrerendered(page) {
        var _a, _b;
        const file = this.pageFiles[page] || '';
        const pageSource = this.getPageSourceType(page) || '';
        let routeKey = (this.defaultLocale ? `/${this.defaultLocale}` : '') + `${page}`;
        if (routeKey !== '/') {
            routeKey = routeKey.replace(/\/$/, '');
        }
        return (file.endsWith('.html') ||
            ((_a = this.prerenderManifest) === null || _a === void 0 ? void 0 : _a.routes[routeKey]) != null ||
            ((_b = this.prerenderManifest) === null || _b === void 0 ? void 0 : _b.dynamicRoutes[page]) != null ||
            (0, fs_1.existsSync)((0, path_1.join)(this.nextRootDir, this.distDir, this.renderMode, pageSource, `${page}.html`)));
    }
    /**
     * Returns true if page is with HTML extension in pages or app paths manifest files.
     * That means that page was statically rendered at build time and had no getServerSideProps or getInitialProps functions.
     * @param pageName
     * @returns
     */
    hasFileWithHtmlExtension(pageName) {
        var _a;
        return ((_a = this.pageFiles[pageName]) === null || _a === void 0 ? void 0 : _a.endsWith('.html')) || false;
    }
    /**
     * Returns object with dataRoute of page
     * or undefined if page has no dataRoute
     * @param pageName
     * @returns
     */
    getDataRoute(pageName) {
        var _a;
        return (_a = this.routesManifest) === null || _a === void 0 ? void 0 : _a.dataRoutes.find((dataRoute) => dataRoute.page === pageName);
    }
    /**
     * Returns the list of prerendered routes of provided page.
     * @param page
     * @returns
     */
    getPrerenderedRoutes(page) {
        var _a;
        const localizedRouteRegex = (0, path_to_regexp_1.pathToRegexp)(page.localizedRoute);
        let pageRoutes = Object.keys(((_a = this.prerenderManifest) === null || _a === void 0 ? void 0 : _a.routes) || {}).filter(route => {
            var _a, _b;
            const srcRoute = (_b = (_a = this.prerenderManifest) === null || _a === void 0 ? void 0 : _a.routes[route]) === null || _b === void 0 ? void 0 : _b.srcRoute;
            // When we have srcRoute, we can pair prerendered route with page based on its page name.
            if (srcRoute)
                return srcRoute === page.name;
            // When we don't have srcRoute, we need to match prerendered route with page route by regex.
            // We'll get here only for pages with static route.
            return !page.isDynamic && route.match(localizedRouteRegex);
        });
        // If page is prerendered during the build and has no getServerSideProps or getStaticProps,
        // the page is not listed in prerender-manifest file.
        // The page has the file .html extension in pages-manifest or app-paths-manifest file instead.
        if (this.hasFileWithHtmlExtension(page.name)) {
            pageRoutes.push(page.name);
        }
        // When localizations is enabled
        if (this.defaultLocale) {
            // If prerendered route is starting with default locale,
            // we need to add the route without locale prefix too.
            // Example: /en-US/blog => /blog
            pageRoutes = pageRoutes.flatMap(route => {
                if (!route.startsWith(`/${this.defaultLocale}`))
                    return route;
                return [route, route.replace(`/${this.defaultLocale}`, '/').replace(/\/\//g, '/')];
            });
        }
        return pageRoutes.map(nextRoute => ({
            nextRoute,
            route: this.nextPathFormatter.toRouteSyntax(nextRoute),
            dataRoute: (page === null || page === void 0 ? void 0 : page.dataRoute)
                ? this.nextPathFormatter.getDataRoute(nextRoute, this.buildId)
                : undefined,
            // Each prerendered route of page can have different initialRevalidateSeconds value,
            // although Next.js is showing only one value in build logs.
            initialRevalidateSeconds: this.getRevalidateSeconds(nextRoute),
        }));
    }
    /**
     * Returns initialRevalidateSeconds value for given prerendered route
     * or undefined when it doesn't exist.
     * @param pageRoute
     * @returns
     */
    getRevalidateSeconds(pageRoute) {
        var _a, _b, _c, _d;
        const revalidationSeconds = (_b = (_a = this.prerenderManifest) === null || _a === void 0 ? void 0 : _a.routes[pageRoute]) === null || _b === void 0 ? void 0 : _b.initialRevalidateSeconds;
        if (revalidationSeconds !== undefined)
            return revalidationSeconds;
        if (this.defaultLocale) {
            return (_d = (_c = this.prerenderManifest) === null || _c === void 0 ? void 0 : _c.routes[`/${this.defaultLocale}${pageRoute}`]) === null || _d === void 0 ? void 0 : _d.initialRevalidateSeconds;
        }
        return undefined;
    }
    /**
     * Returns fallback value for given prerendered route
     * or undefined when it doesn't exist.
     * @param pageRoute
     * @returns
     */
    getFallback(pageRoute) {
        var _a, _b;
        return (_b = (_a = this.prerenderManifest) === null || _a === void 0 ? void 0 : _a.dynamicRoutes[pageRoute]) === null || _b === void 0 ? void 0 : _b.fallback;
    }
    /**
     * Returns previewModeId from prerender-manifest
     * @returns
     */
    getPreviewModeId() {
        var _a, _b;
        return (_b = (_a = this.prerenderManifest) === null || _a === void 0 ? void 0 : _a.preview) === null || _b === void 0 ? void 0 : _b.previewModeId;
    }
    /**
     * Returns locales from routes-manifest
     * @returns
     */
    getLocales() {
        return this.locales || [];
    }
    /**
     * Returns default locale from routes-manifest
     * @returns
     */
    getDefaultLocale() {
        return this.defaultLocale;
    }
    /**
     * Returns true if page name is one of the template names
     * @returns
     */
    isTemplate(pageName) {
        return pageName.match(/\/(_app|_document|_error)$/);
    }
    /**
     * Sorts pages so the most matching dynamic routes are first.
     * The static routes are added at the end.
     * @param pages Page paths
     */
    sortPages(pages) {
        var _a, _b;
        const staticRoutes = pages.filter(p => !p.isDynamic);
        const dynamicRoutes = pages.filter(p => p.isDynamic);
        const dynamicRoutesFromManifest = ((_b = (_a = this.routesManifest) === null || _a === void 0 ? void 0 : _a.dynamicRoutes) !== null && _b !== void 0 ? _b : []);
        // Gets the position of the dynamic pages in the routes-manifest.json
        // This can be use to determine what is the precedence of the dynamic pages
        // as more specific routes should be placed last in Edgio, but in next.js
        // the order is reversed.
        const sortedDynamicRoutes = dynamicRoutesFromManifest.map((p, i) => ({
            route: p.page,
            index: i,
        }));
        const dynamicRoutesSorted = dynamicRoutes
            .map(p => {
            const route = sortedDynamicRoutes.find(r => r.route === p.name);
            return { page: p, order: (route === null || route === void 0 ? void 0 : route.index) || 0 };
        })
            .sort((a, b) => b.order - a.order)
            .map(p => p.page);
        return dynamicRoutesSorted.concat(staticRoutes);
    }
}
exports.default = ManifestParser;
