"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const slash_1 = __importDefault(require("slash"));
const getPageExtensions_1 = require("../util/getPageExtensions");
const localeUtils_1 = require("../util/localeUtils");
class NextPathFormatter {
    /**
     * Provides formatting functions for next paths
     * @param nextConfig The configuration of next
     */
    constructor(nextConfig) {
        /**
         * Removes extensions and index from next path
         *
         * @param pagePath The next page path, for example /products/[id]
         * @example
         * /index.js => /
         * /main.html => /main
         */
        this.toCleanPath = (pagePath) => {
            const pageExtensions = (0, getPageExtensions_1.getPageExtensionsFromConfig)(this.nextConfig);
            // Remove all default extensions or extensions defined in next config file
            for (const extension of pageExtensions) {
                if (pagePath.endsWith(`.${extension}`)) {
                    pagePath = pagePath.replace(new RegExp(`.${extension}$`), '');
                    break;
                }
            }
            return (0, slash_1.default)(`/${pagePath.replace(/(^|)\/?index$/, '')}`).replace(/\/+/g, '/');
        };
        /**
         * Converts next path to express route syntax
         * @example
         * /[param1]/[param2] => /:param1/:param2
         * /[...path] => /:path*
         * @param pagePath The next page path, for example /products/[id]
         */
        this.toRouteSyntax = (pagePath) => {
            let route = (0, slash_1.default)(pagePath
                .replace(/^\//, '') // replace the leading slash if present so we can accept both products/[id].js and /products/[id]
                .replace(/\[\[\.\.\.([^\]]+)\]\]/g, ':$1*') // replace [[...path]] with :path*
                .replace(/\[\.\.\.([^\]]+)\]/g, ':$1+') // replace [...path] with :path+
                .replace(/\[([^\]]+)\]/g, ':$1') // replace [id] with :id
            );
            return this.toCleanPath(route);
        };
        this.nextConfig = nextConfig;
    }
    localize(locales, route) {
        if (locales.length) {
            return `/:locale(${locales.join('|')})?${route}`
                .replace(/\/$/, '') // remove trailing slash if one exists
                .replace(/\)\?\/(index)?\.(json|html)$/, '|index).json'); // accept index.json instead of {locale}.json for the default locale
        }
        return route;
    }
    /**
     * Generates dataRoute from page name
     * @returns
     */
    getDataRoute(pageName, buildId = ':buildId') {
        return `/_next/data/${buildId}${pageName === '/' ? '/index' : pageName}.json`;
    }
    /**
     * Generates route and dataRoute in regex-to-path format from page name
     * and returns object with localized variations of them.
     * @returns
     */
    getRouteVariations(pageName, { buildId, locales } = {}) {
        locales = locales || [];
        buildId = buildId || ':buildId';
        const route = this.toRouteSyntax(pageName);
        // Some pages in pages and app paths manifest file are already with locale prefix,
        // so we need to check it before we can localize it
        const localizedRoute = !(0, localeUtils_1.startsWithLocale)(route, locales) ? this.localize(locales, route) : route;
        // Remove locale if they are provided and the route starts with one of them
        const routeWithoutLocale = (0, localeUtils_1.removeLocale)(route, locales);
        const dataRoute = this.getDataRoute(routeWithoutLocale, buildId);
        const localizedDataRoute = this.getDataRoute(this.localize(locales, routeWithoutLocale), buildId);
        return {
            route,
            localizedRoute,
            dataRoute,
            localizedDataRoute,
        };
    }
}
exports.default = NextPathFormatter;
