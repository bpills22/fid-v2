"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ports_1 = require("../utils/ports");
// Note: This is the main server, that is used for both dev and prod mode.
// Locally in both dev and prod, the CLI imports and starts the server directly.
// In lambda, the server is started as separate process by the handler.ts file
// and the handler.ts file is responsible for converting the lambda event to
// a http request, proxying it to the server instance as well as catching the
// lambda top level errors (level 1) and restarting the server if it crashes.
//
// This file is kept as simple as possible,
// the only thing we expose here is the server instance
// and our code injection for node ClientRequest type. We do this because
// we want to make sure that our type is injected before we execute any
// code. That's why we load lazy our implementation code in server.implementation.ts
const { interceptRequests } = require('./injection/httpRequestInterceptor');
// Load HTTP request interception as soon as possible so that we can monkey patch the underlying
// Node modules before anything else had a chance to take a reference on the original
// classes and functions.
interceptRequests({
    enableHttpRequestLogging: process.env.EDGIO_HTTP_REQUEST_LOGGING === '1',
});
// IMPORTANT: Import the server implementation after the HTTP request interception.
const { startServer } = require('./server.implementation');
const server = startServer(ports_1.port, ports_1.localhost);
exports.default = server;
