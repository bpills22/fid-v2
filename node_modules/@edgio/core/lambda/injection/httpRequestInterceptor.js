// @ts-nocheck
// This entire module is written in JavaScript to allow for *very* precise and low-level overriding of
// built-in NodeJS modules.
'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const url_1 = __importDefault(require("url"));
const util_1 = require("util");
const getBodyLoggingData_1 = __importDefault(require("./getBodyLoggingData"));
const stdStreamsWrapper_1 = require("./stdStreamsWrapper");
const constants_1 = require("../../constants");
const serverMetrics_1 = require("../serverMetrics");
// Regex used to detect when the upstream requests are going to Edgio static backend.
// The format of such domains is `xdn-user-assets-<AWS region>-<AWS Organization ID>.s3.amazonaws.com`
// AWS regions are named `us-east-1`, `us-east-2`, etc.
// AWS Organization IDs are only numbers.
const EDGIO_STATIC_BACKEND_DOMAIN_REGEX = /^xdn-user-assets-[a-zA-Z0-9-]+-[0-9]+\.s3\.amazonaws\.com$/;
// Copied from Node 14.x source code https://github.com/nodejs/node/blob/78680c1cbc8b0c435963bc512e826b2a6227c315/lib/internal/url.js#L1267
function urlToOptions(url) {
    const options = {
        protocol: url.protocol,
        hostname: typeof url.hostname === 'string' && url.hostname.startsWith('[')
            ? url.hostname.slice(1, -1)
            : url.hostname,
        hash: url.hash,
        search: url.search,
        pathname: url.pathname,
        path: `${url.pathname || ''}${url.search || ''}`,
        href: url.href,
    };
    if (url.port !== '') {
        options.port = Number(url.port);
    }
    if (url.username || url.password) {
        options.auth = `${url.username}:${url.password}`;
    }
    return options;
}
// Adapted from Node 14.x source code https://github.com/nodejs/node/blob/78680c1cbc8b0c435963bc512e826b2a6227c315/lib/_http_client.js#L92
let urlWarningEmitted = false;
const searchParams = Symbol('query');
const searchParamsSymbol = searchParams;
function normalizeClientRequestArgs(input, options, cb) {
    if (typeof input === 'string') {
        const urlStr = input;
        try {
            input = urlToOptions(new URL(urlStr));
        }
        catch (err) {
            input = url_1.default.parse(urlStr);
            if (!input.hostname) {
                throw err;
            }
            if (!urlWarningEmitted && !process.noDeprecation) {
                urlWarningEmitted = true;
                process.emitWarning(`The provided URL ${urlStr} is not a valid URL, and is supported ` +
                    'in the http module solely for compatibility.', 'DeprecationWarning', 'DEP0109');
            }
        }
    }
    else if (input && input[searchParamsSymbol] && input[searchParamsSymbol][searchParamsSymbol]) {
        // url.URL instance
        input = urlToOptions(input);
    }
    else {
        cb = options;
        options = input;
        input = null;
    }
    if (typeof options === 'function') {
        cb = options;
        options = input || {};
    }
    else {
        options = Object.assign(input || {}, options);
    }
    return { options, callback: cb };
}
// The original HTTP module ClientRequest. We will use this class
// whenever we are not intercepting the requests.
const OriginalClientRequest = http_1.default.ClientRequest;
// Upstream counter per downstream request. It is reset every time
// the request logging is enabled. Since Lambda is serially executed
// we know that this will never have multiple concurrent requests.
let upstreamRequestCounter = 0;
let upstreamRequestStart = [];
// The current interception options. These are set anew on every new
// lambda (downstream) request.
let upstreamRequestInterceptionOptions = {};
// Inherits native ClientRequest class in order to intercept the
// upstream requests and log them.
function EdgioClientRequest(...args) {
    const { options, callback } = normalizeClientRequestArgs(...args);
    options.headers = options.headers || {};
    addDefaultUserAgent(options.headers);
    addViaHeader(options.headers);
    // We don't log requests going to the same host
    // or edgio_static origin as developers don't
    // expect to see internal platform requests.
    if (!shouldLogRequest(options.hostname || options.host)) {
        // On disabled logging, invoke the native Node ClientRequest.
        return OriginalClientRequest.call(this, options, callback);
    }
    // On enabled logging, patch the native ClientRequest to log request, response and response body.
    const wrappedCallback = patchClientRequest(this, options, callback);
    // After patching and wrapping invoke the native ClientRequest (aka `super`)
    return OriginalClientRequest.call(this, options, wrappedCallback);
}
// Patches the native ClientRequest in order to intercept upstream request and response data and log it.
function patchClientRequest(clientRequest, options, callback) {
    const id = upstreamRequestCounter++;
    upstreamRequestStart[id] = Date.now();
    // For easier log tracking we log some of the upstream request info on upstream requests *and*
    // on upstream responses.
    const upstreamRequestInfo = {
        method: options.method,
        protocol: options.protocol,
        host: options.hostname || options.host,
        port: options.port || (options.protocol === 'https:' ? 443 : 80),
        path: options.path,
    };
    const driLogger = new stdStreamsWrapper_1.deepRequestInspectionLogger();
    const wrappedCallback = res => {
        const bodyBuffers = [];
        res.once('end', () => {
            driLogger.logUpstreamResponseBodyInfo({
                id,
                ...upstreamRequestInfo,
                ...(0, getBodyLoggingData_1.default)(bodyBuffers, res.headers),
            });
        });
        // We only need to log upstream response and intercept the body if the
        // HTTP request logging is enabled.
        if (upstreamRequestInterceptionOptions.enableHttpRequestLogging) {
            driLogger.logUpstreamResponseInfo({
                id,
                ...upstreamRequestInfo,
                statusCode: res.statusCode,
                statusMessage: res.statusMessage || http_1.default.STATUS_CODES[res.statusCode] || 'Unknown',
                headers: res.headers,
                duration: Date.now() - upstreamRequestStart[id],
            });
            let encoding;
            // We need to be aware of changes to the stream's encoding so that we
            // don't accidentally mangle the data.
            const { setEncoding } = res;
            res.setEncoding = function (newEncoding) {
                encoding = newEncoding;
                return setEncoding.apply(this, arguments);
            };
            // Capture the data as it is streamed and log it on end.
            // One danger that this poses is that it, in general case, it will
            // increase the memory use of the function compared to user code
            // running without logging. There is no way to avoid this short of
            // logging buffers as they are coming and even that would not be
            // entirely safe (as decompressing and converting a single buffer
            // to base64 also needs additional memory)
            // Replace res.push with our own implementation that stores chunks
            // We use this approach over subscribing to res.on('data') because
            // subscribing to data event turns the response stream to flowing mode
            // That means the user code might miss some data events if it hasn't subscribed
            // to 'data' event synchronously.
            const origResPush = res.push;
            res.push = function (data) {
                if (data) {
                    if (encoding) {
                        data = Buffer.from(data, encoding);
                    }
                    bodyBuffers.push(data);
                }
                return origResPush.call(res, data);
            };
        }
        if (callback) {
            callback(res);
        }
    };
    // Patch the write and the end methods to intercept the request data.
    const requestBodyBuffers = [];
    // Adds the buffer unless it's actually a callback function passed to
    // `.write` or `.end`.
    const addRequestBodyBuffer = function (buffer, encoding) {
        if (Buffer.isBuffer(buffer) || typeof buffer === 'string') {
            let internalBuffer = buffer;
            if (!Buffer.isBuffer(internalBuffer)) {
                if (typeof encoding !== 'string') {
                    encoding = null;
                }
                internalBuffer = Buffer.from(buffer, encoding);
            }
            requestBodyBuffers.push(internalBuffer);
        }
    };
    clientRequest.write = function (buffer, encoding, callback) {
        // Capture more of the request body. As with response bodies, this
        // posses a problem of larger memory use when compared to user code on its own.
        addRequestBodyBuffer(buffer, encoding);
        return Object.getPrototypeOf(Object.getPrototypeOf(clientRequest)).write.call(clientRequest, buffer, encoding, callback);
    }.bind(clientRequest);
    clientRequest.end = function (buffer, encoding, callback) {
        // Capture the last buffer if it's being written through `.end`.
        addRequestBodyBuffer(buffer, encoding);
        if (upstreamRequestInterceptionOptions.enableHttpRequestLogging) {
            driLogger.logUpstreamRequestInfo({
                id,
                ...upstreamRequestInfo,
                headers: options.headers,
                ...(0, getBodyLoggingData_1.default)(requestBodyBuffers, options.headers),
            });
        }
        return Object.getPrototypeOf(Object.getPrototypeOf(clientRequest)).end.call(clientRequest, buffer, encoding, callback);
    }.bind(clientRequest);
    // We log the first error as some errors like bad certs raise error event multiple times.
    clientRequest.once('error', err => {
        if (upstreamRequestInterceptionOptions.enableHttpRequestLogging) {
            driLogger.logUpstreamResponseInfo({
                id,
                ...upstreamRequestInfo,
                duration: Date.now() - upstreamRequestStart[id],
                code: err && err.code,
                error: err && err.message,
            });
        }
    });
    return wrappedCallback;
}
// EdgioClientRequest extends the native ClientRequest and adds request and response
// logging to it.
(0, util_1.inherits)(EdgioClientRequest, http_1.default.ClientRequest);
// Current ClientRequest class. When not logging requests, this
// is equal to the native HTTP ClientRequest. When logging requests
// this is equal to EdgioClientRequest.
let CurrentClientRequest = OriginalClientRequest;
// Override HTTP and HTTPS `request` functions so that they use
// our current ClientRequest class. We have to do this in lambda
// because by the time we get to override the HTTP/HTTPS modules
// seem already loaded and then set to use native ClientRequest.
// Copied from Node 14.x source code https://github.com/nodejs/node/blob/78680c1cbc8b0c435963bc512e826b2a6227c315/lib/http.js#L49
http_1.default.request = function request(url, options, cb) {
    return new CurrentClientRequest(url, options, cb);
};
// Adapted from Node 14.x source code https://github.com/nodejs/node/blob/78680c1cbc8b0c435963bc512e826b2a6227c315/lib/https.js#L280
https_1.default.request = function request(...args) {
    const { options, callback } = normalizeClientRequestArgs(...args);
    options._defaultAgent = https_1.default.globalAgent;
    return new CurrentClientRequest(options, callback);
};
// Globally enables HTTP request logging by replacing the current ClientRequest
// with EdgioClientRequest.
CurrentClientRequest = EdgioClientRequest;
http_1.default.ClientRequest = EdgioClientRequest;
global.originalFetch = fetch;
global.fetch = async function fetch(urlOrReq, options = {}) {
    const id = upstreamRequestCounter++;
    upstreamRequestStart[id] = Date.now();
    const driLogger = new stdStreamsWrapper_1.deepRequestInspectionLogger();
    options.headers = options.headers || {};
    addDefaultUserAgent(options.headers);
    addViaHeader(options.headers);
    // Don't even try to process request
    // and just call the original fetch if logging is disabled
    if (!upstreamRequestInterceptionOptions.enableHttpRequestLogging) {
        return originalFetch(urlOrReq, options);
    }
    // The request info
    const request = toRequest(urlOrReq, options);
    const url = new URL(request.url);
    // We don't log requests going to the same host
    // or edgio_static origin as developers don't
    // expect to see internal platform requests.
    if (!shouldLogRequest(url.hostname)) {
        return originalFetch(url, options);
    }
    const upstreamRequestInfo = {
        method: request.method,
        protocol: url.protocol,
        host: url.hostname || url.host,
        port: url.port || (url.protocol === 'https:' ? 443 : 80),
        path: url.pathname + url.search,
    };
    // Log the response info
    const requestHeaders = {};
    request.headers.forEach((value, name) => (requestHeaders[name] = value));
    driLogger.logUpstreamRequestInfo({
        id,
        ...upstreamRequestInfo,
        headers: requestHeaders,
        ...(0, getBodyLoggingData_1.default)(options.body || [], options.headers),
    });
    try {
        // Make the fetch request
        const response = await originalFetch(url, options);
        // Clone the response before we consume the body,
        // so we can log the body info and pass clone to the user code.
        const responseClone = response.clone();
        // Log the response info
        const responseHeaders = {};
        response.headers.forEach((value, name) => (responseHeaders[name] = value));
        const responseBodyArrayBuffer = await response.arrayBuffer();
        const responseBodyBuffer = Buffer.from(responseBodyArrayBuffer || []);
        driLogger.logUpstreamResponseInfo({
            id,
            ...upstreamRequestInfo,
            statusCode: response.status,
            statusMessage: response.statusText || http_1.default.STATUS_CODES[response.status] || 'Unknown',
            headers: responseHeaders,
            duration: Date.now() - upstreamRequestStart[id],
        });
        // Log the response body info
        driLogger.logUpstreamResponseBodyInfo({
            id,
            ...upstreamRequestInfo,
            ...(0, getBodyLoggingData_1.default)(responseBodyBuffer, response.headers),
        });
        // Return copy of the response with the original body
        // Note: There's a one edge-case -
        // When we receive 204 No Content response from upstream origin,
        // the response body is empty buffer with zero size. However,
        // when we try to reconstruct such response using Response constructor,
        // the empty string/buffer is not accepted as a valid body for 204 - No Content response status
        // and the body needs to be set to null or undefined instead.
        // The .clone() method handles this case.
        return responseClone;
    }
    catch (err) {
        // Log captured error
        driLogger.logUpstreamResponseInfo({
            id,
            ...upstreamRequestInfo,
            duration: Date.now() - upstreamRequestStart[id],
            code: err && err.code,
            error: err && err.message,
        });
        // Re-throw the error for the user code to handle
        throw err;
    }
};
/**
 * Converts the given input to a Request object.
 * @param input The string | URL | Request to convert
 * @param init The request init options
 */
function toRequest(input, init) {
    if (typeof input === 'string') {
        return new Request(input, init);
    }
    else if (input instanceof URL) {
        return new Request(input.toString(), init);
    }
    else {
        return input;
    }
}
/**
 * Returns true if the request should be logged.
 * Request to localhost or Edgio static assets are not logged.
 * @param hostname
 */
function shouldLogRequest(hostname) {
    return Boolean(hostname &&
        !['127.0.0.1', '0.0.0.0', '::1', '0:0:0:0:0:0:0:1', 'localhost'].includes(hostname) &&
        !EDGIO_STATIC_BACKEND_DOMAIN_REGEX.test(hostname));
}
/**
 * Adds default 'User-Agent' header to the given headers object.
 * @param headers The headers object
 */
function addDefaultUserAgent(headers) {
    // If the user agent is not set, set it to "Edgio"
    const userAgentHeader = Object.keys(headers).find(header => header.toLowerCase() === constants_1.HTTP_HEADERS.userAgent);
    if (!userAgentHeader) {
        headers[constants_1.HTTP_HEADERS.userAgent] = 'Edgio';
    }
}
/**
 * Adds original incoming request's Via header with appended "Edgio",
 * so we can track the request path through the system and detect loops.
 * For example when user tries to itself or another Edgio site.
 */
function addViaHeader(headers) {
    // If the user agent is not set, set it to "Edgio"
    const viaHeader = Object.keys(headers).find(header => header.toLowerCase() === constants_1.HTTP_HEADERS.via);
    if (!viaHeader) {
        headers[constants_1.HTTP_HEADERS.via] = serverMetrics_1.metrics.via;
    }
    headers[constants_1.HTTP_HEADERS.via] = `${headers[constants_1.HTTP_HEADERS.via]}, ${constants_1.EDGIO_VIA_HEADER_VALUE}`;
}
// Replace the current ClientRequest with EdgioClientRequest in order to intercept
// all HTTP requests issued by the user code inside of lambda. This allows us to:
//
// * perform HTTP request logging
// * preserve headers such as `via`
//
// Details:
// * This function resets the internal counters so it cannot be used with concurrent
// downstream requests on a single instance. AWS doesn't support this but if we need
// to support it in local development this would need to be changed to use "thread local storage".
// * Note that the enabling is global as long as it's done at the earliest possible
// time in the lifetime of the process. Otherwise, other modules might make their
// own copies of native ClientRequest and globally replacing it afterwards would
// not work for those modules.
function interceptRequests(options) {
    upstreamRequestCounter = 0;
    upstreamRequestStart = [];
    upstreamRequestInterceptionOptions = options || {};
}
module.exports = {
    interceptRequests,
};
