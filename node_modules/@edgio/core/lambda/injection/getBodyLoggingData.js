"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const zlib_1 = require("zlib");
const constants_1 = require("../../constants");
const log_1 = __importDefault(require("../../log"));
// We limit the logged body due to CloudWatch 256Kb per line limitation,
// CloudWatch costs and, last but not least, websocket exploding on
// larger sizes.
// Tests have shown that 8Kb length results in responsive UI with enough
// captured information.
const MAX_BODY_LENGTH = 8 * 1024;
function base64encode(input) {
    if (Buffer.isBuffer(input)) {
        return input.toString('base64');
    }
    return Buffer.from(input).toString('base64');
}
// Gets the content encoding value from the given headers, no matter
// what case the header has been passed through.
function getContentEncoding(headers) {
    if (!headers) {
        return undefined;
    }
    let encoding = headers[constants_1.HTTP_HEADERS.contentEncoding];
    if (!encoding) {
        for (let name of Object.keys(headers)) {
            if (name.toLowerCase() === constants_1.HTTP_HEADERS.contentEncoding) {
                encoding = headers[name];
                break;
            }
        }
    }
    if (Array.isArray(encoding)) {
        if (encoding.length) {
            encoding = encoding[0];
        }
        else {
            encoding = undefined;
        }
    }
    return encoding;
}
// For the purposes of HTTP request and response logging we log the body.
// This function returns an object with possibly truncated body, full body
// length and a flag set to true if the body was truncated.
// The object is directly included in the HTTP request logging result.
// This functionn never throws as it is just related to logging and we don't
// want a request to ever fail due to logging issues.
function getBodyLoggingData(rawBody, headers) {
    var _a, _b;
    try {
        if (!rawBody || rawBody.length === 0) {
            return {};
        }
        let body;
        if (typeof rawBody === 'string') {
            body = Buffer.from(rawBody);
        }
        else if (Buffer.isBuffer(rawBody)) {
            body = rawBody;
        }
        else if (Array.isArray(rawBody)) {
            body = Buffer.concat(rawBody);
        }
        else {
            // We don't know what we have so the best we can do is return a user visible error.
            return {
                body: base64encode(`Unknown body format: ${typeof rawBody}`),
                // @ts-ignore
                bodyLength: rawBody.length,
                bodyTruncated: true,
            };
        }
        let encoding = (_a = getContentEncoding(headers)) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        try {
            switch (encoding) {
                case constants_1.GZIP_ENCODING: {
                    body = (0, zlib_1.gunzipSync)(body);
                    break;
                }
                case constants_1.BROTLI_ENCODING: {
                    body = (0, zlib_1.brotliDecompressSync)(body);
                    break;
                }
                case constants_1.DEFLATE_ENCODING: {
                    body = (0, zlib_1.inflateSync)(body);
                    break;
                }
                default: {
                    // Nothing to do.
                }
            }
        }
        catch (e) {
            log_1.default.warn(`Couldn't decompress response body [${encoding}] (${e === null || e === void 0 ? void 0 : e.message}). Body will be logged as is.`);
        }
        return {
            body: base64encode(body.slice(0, MAX_BODY_LENGTH)),
            bodyLength: body.length,
            bodyTruncated: body.length > MAX_BODY_LENGTH,
        };
    }
    catch (e) {
        // istanbul ignore next
        return {
            body: base64encode(`Error while getting body logging data: ${e && e.message}`),
            bodyLength: (_b = rawBody === null || rawBody === void 0 ? void 0 : rawBody.length) !== null && _b !== void 0 ? _b : 0,
            bodyTruncated: true,
        };
    }
}
exports.default = getBodyLoggingData;
