/// <reference types="node" />
/// <reference types="node" />
import type { APIGatewayProxyEventV2, Context } from 'aws-lambda';
import { BufferProxyEvent, UnknownEvent } from './eventUtils';
import { ChildProcess } from 'child_process';
/**
 * The console expects the response to be a string.
 */
export type ConsoleResponse = string;
/**
 * The format of the error response for the console.
 */
export type ConsoleErrorResponse = {
    statusCode: number;
    errorMessage: any;
};
/**
 * The universal BufferedResponse object for Lambda Responses.
 */
type BufferedResponse = {
    base64EncodedBody?: string | Buffer;
    unencodedBody: string | Buffer;
    statusCode: number;
    headers: Record<string, string | string[]>;
};
/**
 * The response object for BufferProxyEvent
 * that comes from the invocation made by XDN Buffer Proxy.
 */
export type BufferProxyResponse = {
    body: string | Buffer;
    isBase64Encoded: boolean;
    statusCode: number;
    statusMessage: string;
    multiValueHeaders: Record<string, string[]>;
};
/**
 * The response object for APIGatewayProxyEventV2
 * that comes from the invocation made by Function URL.
 */
export type ApiGatewayV2Response = {
    body: string | Buffer;
    isBase64Encoded: boolean;
    statusCode: number;
    headers: Record<string, string>;
};
type HandlerResponse = BufferProxyResponse | ApiGatewayV2Response | ConsoleResponse | ConsoleErrorResponse;
/**
 * The handler function is the main entry point in the lambda.
 * It's responsible for:
 * - Spawning the server process
 * - Managing the system resources in way that should prevent the crash of whole lambda
 * - Converting the lambda event to node req/res and proxying it to the server
 * - Catching top-level lambda errors and restarting the server if it crashes
 *
 * The reserves the necessary system resources for itself first,
 * and then dedicates the rest of the resources to the server process.
 *
 * This handler is expected to be run in Linux environment
 * only and runs only in AWS Lambda as it's using the native OS APIs.
 * Therefore, it's excluded from the local simulation,
 * that starts the server directly in the main process.
 * @param event
 * @param context
 */
export declare const handler: (event: APIGatewayProxyEventV2 | BufferProxyEvent, context: Context) => Promise<HandlerResponse>;
/**
 * Injects the metrics headers into the response
 * or appends the metrics to the existing header.
 * @param response The lambda response
 */
export declare function addMetrics(response: BufferedResponse): BufferedResponse;
/**
 * Converts universal BufferedResponse to the specific response object
 * based on the lambda event type.
 * @param event The lambda event
 * @param response The universal BufferedResponse
 * @returns HandlerResponse The specific response object
 */
export declare function shapeResponseForEvent(event: UnknownEvent, response: BufferedResponse): HandlerResponse;
/**
 * Handles any error, converts it to EdgioError if necessary,
 * renders error page and returns it as the lambda response.
 * @param e The error
 * @param event The lambda event
 * @returns The lambda response
 */
export declare function handleError(e: any, event: APIGatewayProxyEventV2 | BufferProxyEvent): Promise<BufferedResponse>;
/**
 * Converts the lambda event to node req/res
 * and proxies it to the server.
 * @param event The lambda event
 */
export declare function handleServerResponse(event: APIGatewayProxyEventV2 | BufferProxyEvent): Promise<BufferedResponse>;
/**
 * Measures the time of the lambda invocation
 * and returns timeout error page a few milliseconds
 * before the lambda would actually time out.
 * @param context The lambda context
 */
export declare function handleTimeoutError(context: Context): Promise<BufferedResponse>;
/**
 * Handles any server error and returns
 * error page with error details as the lambda response.
 * @param child The server process
 */
export declare function handleServerError(child?: ChildProcess): Promise<BufferedResponse>;
/**
 * Immediately terminates the server process
 * and clears the reference to it.
 */
export declare function clearServer(): void;
/**
 * Spawns the server as a separate process,
 * waits for the ready message and resolves the promise
 */
export declare function spawnServer(): Promise<ChildProcess>;
/**
 * The total heap memory limit for main process 'handler.ts' in MiB.
 */
export declare function getHandlerHeapLimit(): number;
/**
 * Heap memory limit for child process 'server.ts' in MiB.
 * 50MiB are reserved for the main process 'handler.ts'.
 * NOTE: fremem() and totalmem() are reporting system memory,
 * that is higher than the configured memory limit of the main process.
 */
export declare function getServerHeapLimit(): number;
/**
 * Returns true if the headers object
 * contains a header with value over the limit.
 * @param headers
 */
export declare function containsHeaderOverLimit(headers: Record<string, string | string[]>): boolean;
export {};
