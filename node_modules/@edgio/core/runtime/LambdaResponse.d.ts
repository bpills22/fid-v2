/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import { Writable } from 'stream';
import Response, { ResponseHeaders } from './Response';
import { ServerResponse } from 'http';
/**
 * Helper class useful for cases when:
 *    - response is not available in traditional sense (eg. lambda environment, fiddle, tests)
 *    - we need to run code that is dependant on having an editable response (cache revalidation)
 */
export default class LambdaResponse implements Response {
    isDirectStream: boolean;
    originalStream: Writable | undefined;
    headers: ResponseHeaders;
    statusCode: number;
    statusMessage?: string;
    body?: Buffer | string;
    chunks: any[];
    encodedChunks: any[];
    private onStream;
    private onEnd;
    private onHeaders;
    private onFlush;
    private downstream;
    private encoder?;
    private decoder?;
    private responseStream?;
    private byteLength;
    private maxByteLength;
    isHeadersStreamed: boolean;
    isEnded: boolean;
    isDownstreamInit: boolean;
    isStreaming: boolean;
    isStreamableCallback: () => boolean;
    constructor(responseStream?: Writable, isDirectStream?: boolean, originalStream?: Writable | undefined);
    sendResponse(data: string): void;
    static fromAwsResponseStream(awsResponseStream: Writable): LambdaResponse;
    static fromNodeResponse(response: ServerResponse): LambdaResponse;
    setHeader(name: string, value: unknown): void;
    removeHeader(name: string): void;
    getHeader(name: string): unknown;
    getHeaders(): ResponseHeaders;
    clear(): void;
    clearHeaders(): void;
    isCachable(): boolean;
    write(chunk: string | Buffer): Promise<void>;
    end(): Promise<void>;
    setEncoder(value: Writable): void;
    setDecoder(value: Writable): void;
    setDirectStream(value: boolean): void;
    stream(): void;
    waitForFlush(): Promise<boolean | void>;
    initDownstream(): void;
    setIsStreamable(callback: (() => boolean) | boolean): (() => boolean) | undefined;
    isStreamable(): boolean;
    setOnStream(callback: () => void): void;
    setOnEnd(callback: () => void): void;
    setOnHeaders(callback: () => void): void;
    getData(): {
        body: string | Buffer | undefined;
        statusCode: number;
        statusMessage: string | undefined;
        headers: ResponseHeaders;
    };
    /**
     * Injects the metrics headers into the response
     * @private
     */
    addMetrics(): void;
    /**
     * Sets the response header to a new value by prefixing it with the given value or,
     * if it doesn't exist, by setting it to the given value,
     *
     * @param headerName The name of the header to prefix or set
     * @param prefixValue The value of the prefix without trailing comma
     * @private
     */
    prefixResponseHeader(headerName: string, prefixValue: string): void;
}
