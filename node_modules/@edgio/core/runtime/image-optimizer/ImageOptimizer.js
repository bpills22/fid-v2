"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImageOptimizer = void 0;
const types_1 = require("./types");
const log_1 = __importDefault(require("../../log"));
/**
 * The Image Optimizer
 * that can be used to optimize and transform images.
 * See https://docs.edg.io/guides/v7/performance/image_optimization
 * and https://docs.edgecast.com/cdn/Content/HTTP_and_HTTPS_Data_Delivery/Edge-IO.htm#EdgeImageOptimizer
 * for all details and options.
 */
class ImageOptimizer {
    constructor(config = {}) {
        this.config = config;
    }
    /**
     * Optimizes the image in the buffer
     * and returns it as a new buffer.
     * @param input
     */
    async optimize(input) {
        // Load the sharp module if it's not loaded yet.
        const sharp = await this.getSharp();
        // Return the original image
        // if the sharp module is not available.
        if (!sharp)
            return { output: input };
        const startTime = performance.now();
        const image = sharp(input);
        const { format: originalFormat = 'jpg', width: originalWidth = 0, height: originalHeight = 0, } = await image.metadata();
        // The default values should match the values
        // of the Sailfish's Image Optimizer.
        const { rotate, trim, blur, pad, fit = 'default', canvas, dpr = 1, strip = true, format = originalFormat, quality = 80, bgColor: background = { r: 255, g: 255, b: 255, alpha: 1 }, } = this.config;
        const shouldResize = Boolean(this.config.width || this.config.height);
        const widthRatio = originalWidth / originalHeight;
        const heightRatio = originalHeight / originalWidth;
        // Get the new width and height values
        // and multiply them by the provided device pixel ratio.
        let height = this.config.height ? this.config.height * dpr : 0;
        let width = this.config.width ? this.config.width * dpr : 0;
        // We do some adjustments to the width and height
        // based on used fit option to match the Sailfish's behavior
        // as close as possible because the sharp's fit options behave differently.
        // This is not 100% accurate, but it's good enough for most cases.
        if (fit === types_1.FIT_OPTIONS.smart || fit === types_1.FIT_OPTIONS.crop) {
            width = width || originalWidth;
            height = height || width;
        }
        if (fit === types_1.FIT_OPTIONS.cover) {
            if (width && !height) {
                height = width;
                width = 0;
            }
            else if (!width && height) {
                height = originalHeight;
                width = originalWidth;
            }
            else {
                width = width > height ? width : 0;
                height = height > width ? height : 0;
            }
        }
        // Calculate the current width and height of the image after resizing
        // Sharp doesn't allow use to retrieve these updated values
        // from the image metadata without converting the image to buffer that will add extra overhead.
        // That's why we need to calculate them manually here.
        height = height || Math.round((width || originalWidth) * heightRatio);
        width = width || Math.round((height || originalHeight) * widthRatio);
        // NOTE: The order of the below transformations matters,
        // so please don't change it unless you check the actual behavior.
        // Resizes the image. We need to maintain the aspect ratio of the image
        // by default if only one dimension is provided.
        if (shouldResize)
            image.resize(width, height, {
                background,
                fit: this.toSharpFit(fit),
            });
        if (rotate) {
            image.rotate(rotate, {
                background,
            });
        }
        if (blur) {
            image.blur(blur);
        }
        // Strip removes all metadata such as EXIF, IPTC-IIM, XMP, etc... from the image.
        if (!strip) {
            // NOTE: This method exists but the sharp type definition
            // is outdated because it's not generated from the source code.
            // @ts-ignore
            image === null || image === void 0 ? void 0 : image.keepMetadata();
        }
        // Trim crops the edges of the given size from the image.
        if (trim) {
            image.extract({
                top: this.toPixels(trim.top, height),
                left: this.toPixels(trim.left, width),
                width: width - this.toPixels(trim.left, width) - this.toPixels(trim.right, width),
                height: height - this.toPixels(trim.top, height) - this.toPixels(trim.bottom, height),
            });
        }
        // Canvas crops the image to the provided canvas size and offset
        // if the image is larger than the canvas and pads the image
        // if the image is smaller than the provided canvas.
        if (canvas) {
            const cropWidth = canvas.width + canvas.xOffset > width ? width : canvas.width;
            const cropHeight = canvas.height + canvas.yOffset > height ? height : canvas.height;
            const xPadding = canvas.width > width ? canvas.width - width : 0;
            const yPadding = canvas.height > height ? canvas.height - height : 0;
            image.extract({
                top: canvas.yOffset,
                left: canvas.xOffset,
                width: cropWidth,
                height: cropHeight,
            });
            image.extend({
                background,
                top: yPadding / 2,
                bottom: yPadding / 2,
                left: xPadding / 2,
                right: xPadding / 2,
            });
        }
        // Pad adds border to the image
        // with the provided background color.
        if (pad) {
            image.extend({
                background,
                top: this.toPixels(pad.top, height),
                bottom: this.toPixels(pad.bottom, height),
                left: this.toPixels(pad.left, width),
                right: this.toPixels(pad.right, width),
            });
        }
        // Quality has no effect on the webp format in toFormat method.
        // That's why we need to use webp method instead.
        if (format == 'webp') {
            image.webp({
                quality,
                alphaQuality: quality,
            });
        }
        else if (format) {
            // Format converts the image to the provided format
            // and optimizes it based on the provided quality.
            image.toFormat(format, {
                progressive: true,
                force: true,
                quality,
            });
        }
        // Convert the image back to the buffer.
        const output = await image.toBuffer();
        // Return the optimized image and metadata
        // that can be used for debugging purposes.
        return {
            output,
            metadata: {
                inputSize: input.length,
                outputSize: output.length,
                inputFormat: originalFormat,
                outputFormat: format,
                inputHeight: originalHeight,
                outputHeight: height,
                inputWidth: originalWidth,
                outputWidth: width,
                outputQuality: quality,
                duration: performance.now() - startTime,
            },
        };
    }
    /**
     * Dynamically loads the sharp module
     */
    async getSharp() {
        try {
            if (this.cachedSharp)
                return this.cachedSharp;
            // Find the path to the sharp module dynamically
            // to prevent esbuild from resolving it during the build.
            const sharpPath = require.resolve('sharp');
            // The sharp module should not be bundled with the @edgio/core in order to reduce the size of the
            // lambda folder. That's why we're using dynamic import here.
            this.cachedSharp = (await import(sharpPath)).default;
            return this.cachedSharp;
        }
        catch {
            log_1.default.error(`[ImageOptimizer] Couldn't load the 'sharp' module. ` +
                `Edgio Image Optimizer requires the sharp's binaries to be installed for its local simulation, otherwise images will be returned unchanged. ` +
                `If you see this message, that means your package manager didn't install the 'sharp' module correctly or it's not available for your platform.\r\n` +
                `Possible solutions:\r\n` +
                `\t1. Run 'npm install --include=optional sharp' or 'yarn add sharp --ignore-engines' if you're using older version of npm/yarn.\r\n` +
                `\t2. Ensure your package manager supports multi-platform installation: https://sharp.pixelplumbing.com/install#multi-platform\r\n` +
                `\t3. Add platform-specific dependencies. For example: npm install --os=linux --cpu=x64 sharp\r\n` +
                `\t4. Check the sharp's installation guide: https://sharp.pixelplumbing.com/install\r\n`);
            return undefined;
        }
    }
    /**
     * Calculates the number of pixels for the given value.
     * The value is treated as percentage of the image size
     * in case the value is less than 1 and as pixels otherwise.
     * For example: 0.5 means 50% of the image size after resizing.
     * For example: 10 means 10px
     * @param value
     * @param length
     */
    toPixels(value, length) {
        if (value >= 1)
            return value;
        return Math.round(value * length);
    }
    /**
     * Converts our Image Optimizer fit option
     * to most similar sharp's fit option.
     * @param edgioFit
     */
    toSharpFit(edgioFit) {
        const map = {
            cover: 'cover',
            crop: 'cover',
            bounds: 'outside',
            smart: 'cover',
            default: 'fill',
        };
        return (map[edgioFit] || map.default);
    }
}
exports.ImageOptimizer = ImageOptimizer;
