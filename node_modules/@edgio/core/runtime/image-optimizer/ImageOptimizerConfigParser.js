"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImageOptimizerConfigParser = void 0;
const types_1 = require("./types");
const ImageOptimizerError_1 = require("./ImageOptimizerError");
const colorUtils_1 = require("../../utils/colorUtils");
class ImageOptimizerConfigParser {
    static parseFromRequest(req) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const query = req.query;
        const headers = req.headers;
        const config = {};
        // Query string params
        // Syntax: ?bg-color=<COLOR HEX CODE>
        // Syntax: ?bg-color=<RED>,<GREEN>,<BLUE>
        // Syntax: ?bg-color=<RED>,<GREEN>,<BLUE>,<ALPHA CHANNEL>
        if (query['bg-color']) {
            const values = this.parseStrings(query['bg-color']);
            if (values.length === 1) {
                config.bgColor = (0, colorUtils_1.hexToRgba)(values[0]);
            }
            if (values.length === 3 || values.length === 4) {
                config.bgColor = {
                    r: Number(values[0]),
                    g: Number(values[1]),
                    b: Number(values[2]),
                    alpha: Number(values[3] || 1),
                };
            }
            if (!config.bgColor ||
                Object.values(config.bgColor).some(value => isNaN(value) || value < 0 || value > 255) ||
                config.bgColor.alpha < 0 ||
                config.bgColor.alpha > 1) {
                throw new ImageOptimizerError_1.ImageOptimizerError(`Invalid bg-color option. Valid values are HEX color ('#202020'), RGB ('255,255,0') or RGBA color ('255,255,0,0.5').`);
            }
        }
        // Syntax: ?blur=<VALUE 0-100>
        if (query['blur']) {
            config.blur = this.parseNumber(query['blur']);
            if (config.blur && (config.blur <= 0 || config.blur > 100)) {
                throw new ImageOptimizerError_1.ImageOptimizerError(`Invalid blur option. Value needs to be in range 1-100.`);
            }
        }
        // Syntax: ?canvas=<CANVAS WIDTH>,<CANVAS HEIGHT>
        // Syntax: ?canvas=<CANVAS WIDTH>,<CANVAS HEIGHT>,x<X-COORDINATE>,y<Y-COORDINATE>
        if (query['canvas']) {
            const values = this.parseNumbers(query['canvas']);
            if (values.length < 2 || values.length > 4) {
                throw new ImageOptimizerError_1.ImageOptimizerError(`Invalid canvas option. Valid format is: 'width,height,xOffset?,yOffset?'`);
            }
            config.canvas = {
                width: values[0],
                height: values[1],
                xOffset: values[2] || 0,
                yOffset: values[3] || 0,
            };
        }
        // Syntax: ?dpr=<RATIO 1-10>
        if (query['dpr']) {
            config.dpr = this.parseNumber(query['dpr']) || 1;
            if (config.dpr <= 0 || config.dpr > 10) {
                throw new ImageOptimizerError_1.ImageOptimizerError(`Invalid dpr option. Valid values are 0 < dpr <= 10`);
            }
        }
        // Syntax: ?fit=<OPTION>
        if (query['fit']) {
            config.fit = this.parseStrings(query['fit']).pop() || '';
            if (!Object.values(types_1.FIT_OPTIONS).includes(config.fit)) {
                throw new ImageOptimizerError_1.ImageOptimizerError(`Invalid fit option. Valid values are ${Object.values(types_1.FIT_OPTIONS).join(', ')}`);
            }
        }
        // Syntax: ?format=<OPTION>
        if (query['format']) {
            config.format = this.parseStrings(query['format']).shift() || '';
            if (!types_1.SUPPORTED_EXTENSIONS.includes(config.format)) {
                throw new ImageOptimizerError_1.ImageOptimizerError(`Invalid format option. Valid values are ${types_1.SUPPORTED_EXTENSIONS.join(', ')}`);
            }
        }
        // Syntax: ?height=<VALUE 1-4096>
        if (query['height']) {
            config.height = this.parseNumber(query['height']);
            if (config.height && (config.height <= 0 || config.height > 4096)) {
                throw new ImageOptimizerError_1.ImageOptimizerError(`Invalid height option. Value needs to be in range 1-4096.`);
            }
        }
        // Syntax: ?width=<VALUE 1-4096>
        if (query['width']) {
            config.width = this.parseNumber(query['width']);
            if (config.width && (config.width <= 0 || config.width > 4096)) {
                throw new ImageOptimizerError_1.ImageOptimizerError(`Invalid width option. Value needs to be in range 1-4096.`);
            }
        }
        // Syntax: ?pad=<TOP>,<RIGHT>,<BOTTOM>,<LEFT>
        // Syntax: ?pad=<TOP>,<LEFT & RIGHT>,<BOTTOM>
        // Syntax: ?pad=<TOP & BOTTOM>,<LEFT & RIGHT>
        // Syntax: ?pad=<ALL POSITIONS>
        if (query['pad']) {
            const values = this.parseNumbers(query['pad']);
            if (values.length < 1 || values.length > 4) {
                throw new ImageOptimizerError_1.ImageOptimizerError(`Invalid pad option. Valid format is: 'top,right?,bottom?,left?'`);
            }
            config.pad = {
                top: values[0],
                bottom: values[1] || values[0],
                left: values[2] || values[0],
                right: values[3] || values[0],
            };
            if (values.length === 3 || values.length === 2) {
                config.pad.left = values[1];
                config.pad.right = values[1];
            }
        }
        // Syntax: ?quality=<VALUE 0-100>
        if (query['quality']) {
            config.quality = this.parseNumber(query['quality']);
            if (config.quality && (config.quality < 0 || config.quality > 100)) {
                throw new ImageOptimizerError_1.ImageOptimizerError(`Invalid quality option. Value needs to be in range 0-100.`);
            }
        }
        // Syntax: ?rotate=<VALUE 0-360>
        if (query['rotate']) {
            config.rotate = this.parseNumber(query['rotate']);
            if (config.rotate && (config.rotate < 0 || config.rotate > 360)) {
                throw new ImageOptimizerError_1.ImageOptimizerError(`Invalid rotate option. Value needs to be in range 0-360.`);
            }
        }
        // Syntax: ?strip=<BOOLEAN 0-1>
        if (query['strip']) {
            config.strip = query['strip'] === '1';
        }
        // Syntax: ?trim=<TOP>,<RIGHT>,<BOTTOM>,<LEFT>
        // Syntax: ?trim=<TOP>,<LEFT & RIGHT>,<BOTTOM>
        // Syntax: ?trim=<TOP & BOTTOM>,<LEFT & RIGHT>
        // Syntax: ?trim=<ALL POSITIONS>
        if (query['trim']) {
            const values = this.parseNumbers(query['trim']);
            if (values.length < 1 || values.length > 4) {
                throw new ImageOptimizerError_1.ImageOptimizerError(`Invalid trim option. Valid format is: 'top,right?,bottom?,left?'`);
            }
            config.trim = {
                top: values[0],
                bottom: values[1] || values[0],
                left: values[2] || values[0],
                right: values[3] || values[0],
            };
            if (values.length === 3 || values.length === 2) {
                config.trim.left = values[1];
                config.trim.right = values[1];
            }
        }
        // Syntax: ?wurfl=<BOOLEAN 0-1>
        if (query['wurfl']) {
            config.wurfl = query['wurfl'] === '1';
        }
        // Syntax: ?auto=<OPTION>
        // Syntax: ?auto=<OPTION>,<OPTION>
        if (query['auto']) {
            config.auto = this.parseStrings(query['auto']);
            if (config.auto.some(option => !Object.values(types_1.AUTO_OPTIONS).includes(option))) {
                throw new ImageOptimizerError_1.ImageOptimizerError(`Invalid auto option. Valid values are ${Object.values(types_1.AUTO_OPTIONS).join(', ')}`);
            }
            // If the auto option is set to webp,
            // we always convert to webp if the client accepts the webp content-type or all types.
            // Example: Accept: image/webp,image/apng,image/*,*/*;q=0.8
            if (((_a = config.auto) === null || _a === void 0 ? void 0 : _a.includes(types_1.AUTO_OPTIONS.webp)) &&
                (((_b = headers.accept) === null || _b === void 0 ? void 0 : _b.toString().includes(types_1.SUPPORTED_TYPES[types_1.AUTO_OPTIONS.webp])) ||
                    ((_c = headers.accept) === null || _c === void 0 ? void 0 : _c.toString().includes('*/*')))) {
                config.format = types_1.AUTO_OPTIONS.webp;
            }
            // If the auto config option contain save-data option and save-data header is sent with 'on' value,
            // we set the quality to 45% and strip param to true.
            // Example: save-data: on
            if ((_d = config.auto) === null || _d === void 0 ? void 0 : _d.includes(types_1.AUTO_OPTIONS.saveData)) {
                const value = (_f = (_e = headers['save-data']) === null || _e === void 0 ? void 0 : _e.toString()) === null || _f === void 0 ? void 0 : _f.toLowerCase();
                if (value === 'on') {
                    config.quality = 45;
                    config.strip = true;
                }
            }
            // If the auto config option contain the smallest option,
            // we set the quality to 35% to serve the smallest possible size of image.
            if ((_g = config.auto) === null || _g === void 0 ? void 0 : _g.includes(types_1.AUTO_OPTIONS.smallest)) {
                config.quality = 35;
            }
        }
        // Downlink header reduces image quality to 60% and strips metadata
        // when the header includes value below 0.5.
        // Example: downlink: 1.7
        if (headers['downlink']) {
            const value = this.parseNumber(headers['downlink'].toString());
            if (value && value < 0.5) {
                config.quality = 60;
                config.strip = true;
            }
        }
        // The DPR request header overrides the dpr query string parameter.
        // Example: dpr: 2.0
        if (headers['dpr']) {
            config.dpr = this.parseNumber(headers['dpr'].toString());
        }
        // We reduces image quality to 60% and strips metadata
        // when the request includes an ECT header,
        // and it is set to a value other than 4g or 3g.
        // Example: ect: 2g
        if (headers['ect']) {
            const value = (_h = headers['ect']) === null || _h === void 0 ? void 0 : _h.toString();
            if (value && !['4g', '3g'].includes(value.toLowerCase())) {
                config.quality = 60;
                config.strip = true;
            }
        }
        // The viewport-width request header overrides the width and height query string parameters.
        // Example: viewport-width: 1024
        if (headers['viewport-width']) {
            const value = this.parseNumber(headers['viewport-width'].toString());
            if (value) {
                config.width = value;
                config.height = undefined;
            }
        }
        // The width request header overrides the width query string parameters
        // and the viewport-width header.
        // Example: width: 320
        if (headers['width']) {
            const value = this.parseNumber(headers['width'].toString());
            config.width = value || config.width;
        }
        return config;
    }
    static parseNumber(value) {
        const parsed = Number(value === null || value === void 0 ? void 0 : value.toString());
        if (!isNaN(parsed))
            return parsed;
        return undefined;
    }
    static parseStrings(value) {
        const parsed = typeof value === 'string' ? value.split(',') : value;
        return (parsed || []).filter(item => item.length > 0);
    }
    static parseNumbers(value) {
        return this.parseStrings(value)
            .map(item => Number(item))
            .filter(item => !isNaN(item));
    }
}
exports.ImageOptimizerConfigParser = ImageOptimizerConfigParser;
