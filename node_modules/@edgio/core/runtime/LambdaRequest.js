"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const QueryString = __importStar(require("qs"));
const environment_1 = require("../environment");
const constants_1 = require("../constants");
/**
 * Data holder for lambda request.

 * Useful for cases when request needs to be created for:
 *    - lambda invocation / reqResMapper
 *    - findMatchingRules invocation
 *    - fiddle RequestContext invocation
 *    - tests (mainly ones invoking RequestContext directly)
 */
class LambdaRequest {
    constructor(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
        this.url = '/';
        this.path = '/';
        this.rawHeaders = [];
        this.query = {};
        this.method = 'GET';
        this.protocol = 'http';
        this.secure = true;
        this.socket = { remoteAddress: '127.0.0.1', encrypted: true };
        this.connection = { encrypted: true };
        this.httpVersion = '1.1';
        this.port = '443';
        this.options = options;
        this.invokeAction = options.invokeAction;
        this.invokeSource = options.invokeSource;
        this.url = options.url.pathname + ((_a = options.url.search) !== null && _a !== void 0 ? _a : '');
        this.query = QueryString.parse((_b = options.url.search) !== null && _b !== void 0 ? _b : '', { ignoreQueryPrefix: true });
        this.rawUrl = options.rawUrl;
        this.path = options.url.pathname;
        this.method = (_c = options.method) !== null && _c !== void 0 ? _c : this.method;
        // Compatibility with https://nodejs.org/api/all.html#http_message_headers
        // Header names *are* lower-cased to maintain Node compatibility.
        this.headers = normalizeHeaders((_d = options.headers) !== null && _d !== void 0 ? _d : {});
        // We need to set the correct host header here.
        // Behind the edge, the host header is set to override_host_header origin config value,
        // but the real host is passed in x-host header.
        // NOTE: The real lambda function URL shouldn't customers see,
        // so it's also important to override it here.
        // @example
        // Host: cqaxwkomusknlwhrmm46jg2v.lambda-url.us-east-2.on.aws
        // x-host: example-site.glb.edgio-dev.link
        const host = options.url.host || this.getHeader(constants_1.HTTP_HEADERS.xHost) || this.getHeader(constants_1.HTTP_HEADERS.host);
        this.setHeader('host', host || 'localhost');
        for (const key of Object.keys(this.headers)) {
            // Compatibility with https://nodejs.org/api/all.html#http_message_rawheaders
            // Header names are not lower-cased to maintain Node compatibility.
            const header = this.headers[key];
            for (const value of Array.isArray(header) ? header : [header]) {
                this.rawHeaders.push(key);
                this.rawHeaders.push(value);
            }
        }
        this.httpVersion = (_e = options.httpVersion) !== null && _e !== void 0 ? _e : this.httpVersion;
        // This is needed for matching on request.client_ip.
        // The client ip is the first value in x-forwarded-for header behind the edge.
        // The rest are another proxies.
        // @example x-forwarded-for: 193.0.0.1, 1.1.1.2, 1.1.1.3
        this.socket.remoteAddress = (((_h = (_g = (_f = this.getHeader(constants_1.HTTP_HEADERS.xForwardedFor)) === null || _f === void 0 ? void 0 : _f.toString()) === null || _g === void 0 ? void 0 : _g.split(',')) === null || _h === void 0 ? void 0 : _h[0]) || this.socket.remoteAddress);
        if (options.url.protocol) {
            // protocol trails with ':' locally, which is expected to be removed
            this.protocol = (_j = options.url.protocol) === null || _j === void 0 ? void 0 : _j.replace(':', '');
        }
        else if (!(0, environment_1.isLocal)()) {
            // Extract correct protocol for XBP permalinks
            // TODO: Remove this when EDGE_PERMALINKS are enabled for all customers
            const xbpProtocol = (_k = this.getHeader(constants_1.HTTP_HEADERS.x0Protocol)) === null || _k === void 0 ? void 0 : _k.toString();
            // NOTE: Sailfish is always sending x-forwarded-proto: "https" header
            // even when the HTTP protocol is used. We need know the original protocol used by the client,
            // because the request is always sent to Function URL with HTTPS protocol.
            // The right protocol seems to be the one from the via header.
            const viaProtocol = (_p = (_o = (_m = (_l = this.getHeader(constants_1.HTTP_HEADERS.via)) === null || _l === void 0 ? void 0 : _l.toString()) === null || _m === void 0 ? void 0 : _m.split('/')) === null || _o === void 0 ? void 0 : _o.shift()) === null || _p === void 0 ? void 0 : _p.toLowerCase();
            const xForwardedProtocol = (_r = (_q = this.getHeader(constants_1.HTTP_HEADERS.xForwardedProto)) === null || _q === void 0 ? void 0 : _q.toString()) === null || _r === void 0 ? void 0 : _r.toLowerCase();
            this.protocol = xbpProtocol || viaProtocol || xForwardedProtocol || 'https';
        }
        // We need to set the correct port behind the edge.
        // The x-forwarded-port	header seems to have the same issue as x-forwarded-proto.
        this.port = options.url.port || this.protocol === 'https' ? '443' : '80';
        // Reassign the x-forwarded-* headers,
        // se they are always present and in sync with the values in the request.
        this.setHeader(constants_1.HTTP_HEADERS.xForwardedProto, this.protocol);
        this.setHeader(constants_1.HTTP_HEADERS.xForwardedPort, this.port);
        this.setHeader(constants_1.HTTP_HEADERS.xForwardedFor, this.socket.remoteAddress);
        // req.secure is ExpressJS extension, set to false only when the app is running locally or the protocol is HTTP
        // (so the default remains HTTPS which has historically been the only protocol we allowed)
        this.secure = this.protocol === 'https';
        // Depending on the version req.socket.encrypted is set to true by NodeJS when the protocol is HTTPS.
        this.socket.encrypted = this.secure;
        // Depending on the version req.connection.encrypted is set to true by NodeJS when the protocol is HTTPS.
        this.connection.encrypted = this.secure;
        this._rawBody = options.rawBody || Buffer.from((_s = options.body) !== null && _s !== void 0 ? _s : '');
    }
    static async fromNodeRequest(request) {
        var _a;
        const body = await new Promise(resolve => {
            const bodyParts = [];
            let body;
            request
                .on('data', (chunk) => {
                bodyParts.push(chunk);
            })
                .on('end', () => {
                body = Buffer.concat(bodyParts);
                resolve(body);
            });
        });
        const url = new URL(request.url, `http://${request.headers.host}`);
        const invokeAction = request.headers[constants_1.HTTP_HEADERS.xEdgInvokeAction];
        const invokeSource = request.headers[constants_1.HTTP_HEADERS.xEdgInvokeSource];
        // Original URL from the invocation event without encoded/decoded query
        const rawUrl = ((_a = request.headers[constants_1.HTTP_HEADERS.xEdgRawUrl]) === null || _a === void 0 ? void 0 : _a.toString()) || `${url.pathname}${url.search}`;
        return new LambdaRequest({
            url: {
                // Normalize pathname to have only one unencoded slash between segments
                // Example: /a//b -> /a/b
                pathname: url.pathname.replace(/\/+/g, '/'),
                search: url.search,
            },
            rawUrl,
            method: request.method,
            headers: request.headers,
            body,
            invokeAction,
            invokeSource,
        });
    }
    /**
     * Returns a clone of the original request, before any properties were altered.
     */
    cloneOriginal() {
        return new LambdaRequest(this.options);
    }
    setHeader(name, value) {
        this.headers[name.toLowerCase()] = value;
    }
    getHeader(name) {
        return this.headers[name.toLowerCase()];
    }
    getHeaders() {
        return this.headers;
    }
    removeHeader(name) {
        delete this.headers[name.toLowerCase()];
    }
    get body() {
        return this.rawBody.toString('utf8');
    }
    set body(value) {
        this.rawBody = Buffer.from(value || '');
    }
    get rawBody() {
        return this._rawBody;
    }
    set rawBody(value) {
        this._rawBody = value;
        this.setHeader(constants_1.HTTP_HEADERS.contentLength, this.rawBody.length.toString());
    }
}
exports.default = LambdaRequest;
// sets all headers to lowercase names, and 'flattens' the array values if they contain only one element
function normalizeHeaders(headers) {
    let result = {};
    for (let name in headers) {
        const header = headers[name];
        result[name.toLowerCase()] =
            Array.isArray(header) && header.length === 1 ? header[0] : header;
    }
    return result;
}
