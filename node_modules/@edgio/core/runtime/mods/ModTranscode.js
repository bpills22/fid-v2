"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Mod_1 = __importDefault(require("./Mod"));
const Phase_1 = __importDefault(require("../Phase"));
const constants_1 = require("../../constants");
const zlib_1 = __importDefault(require("zlib"));
const headerUtils_1 = require("../../utils/headerUtils");
/**
 * A helper function to get the first value from the array, or the value itself if it's not an array.
 */
const getFirstOrValue = (value) => {
    return (Array.isArray(value) ? value[0] : value);
};
/**
 * Those content types that will be gzipped are generated from the lists in:
 * our Edgio v1 production Nginx + Edgio v1 production Varnish + default CDN gzip policy
 *
 * Set is not always optimal but in the benchmarks came out on top the most times.
 * It is also the easiest to read and check for correctness.
 *
 * NOTE: this is not related to sailfish, but rather previous implementation of encoding
 * we were returning from app. Therefore, we use this only in production / when not running simulator.
 */
const COMPRESSIBLE_TYPES = new Set([
    'application/atom_xml',
    'application/javascript',
    'application/json',
    'application/rss+xml',
    'application/vnd.ms-fontobject',
    'application/x-font-opentype',
    'application/x-font-ttf',
    'application/x-javascript',
    'application/xhtml+xml',
    'application/xml',
    'application/xml+rss',
    'font/eot',
    'font/opentype',
    'font/otf',
    'image/svg+xml',
    'image/x-icon',
    'text/css',
    'text/html',
    'text/javascript',
    'text/js',
    'text/plain',
]);
/**
 * Emulation of Sailfish's mod_transcode
 */
class ModTranscode extends Mod_1.default {
    async execute(phase) {
        // we return early if response is not encodable
        if (!this.isEncodable())
            return;
        if ((this.context.useCacheFile && phase === Phase_1.default.HandleDocRoot) ||
            phase === Phase_1.default.StreamResponse ||
            phase === Phase_1.default.HandleResponseHeader) {
            const request = this.context.getRequest();
            const response = this.context.getResponse();
            const contentEncoding = getFirstOrValue(response.getHeader(constants_1.HTTP_HEADERS.contentEncoding));
            const acceptEncoding = getFirstOrValue(request.getHeader(constants_1.HTTP_HEADERS.acceptEncoding));
            const BROTLI_ENCODING_REGEX = /\bbr\b/;
            const GZIP_ENCODING_REGEX = /\bgzip\b/;
            const DEFLATE_ENCODING_REGEX = /\bdeflate\b/;
            // this will check whether the downstream is ALREADY compatible with the encoding
            // (which means that encoders are alraday set, and we dont need to do anything)
            const downstreamIsGzipCompatible = GZIP_ENCODING_REGEX.test(acceptEncoding);
            const downstreamIsBrotliCompatible = BROTLI_ENCODING_REGEX.test(acceptEncoding);
            const downstreamIsDeflateCompatible = DEFLATE_ENCODING_REGEX.test(acceptEncoding);
            if (downstreamIsGzipCompatible && contentEncoding === constants_1.GZIP_ENCODING) {
                return;
            }
            if (downstreamIsBrotliCompatible && contentEncoding === constants_1.BROTLI_ENCODING) {
                return;
            }
            if (downstreamIsDeflateCompatible && contentEncoding === constants_1.DEFLATE_ENCODING) {
                return;
            }
            // we delete content-length, as we cant know it before reencoding
            response.removeHeader(constants_1.HTTP_HEADERS.contentLength);
            response.setHeader(constants_1.HTTP_HEADERS.transferEncoding, 'chunked');
            // left here for testing purposes - undefined == default chunk size
            const chunkSize = undefined;
            switch (contentEncoding) {
                case constants_1.BROTLI_ENCODING:
                    response.setDecoder(zlib_1.default.createBrotliDecompress({
                        chunkSize,
                    }));
                    break;
                case constants_1.GZIP_ENCODING:
                    response.setDecoder(zlib_1.default.createGunzip({ chunkSize }));
                    break;
                case constants_1.DEFLATE_ENCODING:
                    response.setDecoder(zlib_1.default.createInflate({ chunkSize }));
                    break;
            }
            let contentType = response.getHeader(constants_1.HTTP_HEADERS.contentType);
            if (Array.isArray(contentType)) {
                contentType = contentType[0];
            }
            const parsedContentType = contentType && (0, headerUtils_1.parseContentType)(contentType).type.toLowerCase();
            if (this.context.executingSimulator ||
                (parsedContentType && COMPRESSIBLE_TYPES.has(parsedContentType))) {
                // If multiple are compatible,
                // we'll choose them in the order of: brotli, gzip, deflate
                if (downstreamIsBrotliCompatible) {
                    response.setEncoder(zlib_1.default.createBrotliCompress({
                        chunkSize,
                        params: {
                            // TODO: probably should be settable through some header? is there some spec for it? default is 11, which is 37.29Kbps, 7 is 2.7Mbps etc.
                            // https://quixdb.github.io/squash-benchmark/#results-table
                            [zlib_1.default.constants.BROTLI_PARAM_QUALITY]: 5,
                        },
                    }));
                    response.setHeader(constants_1.HTTP_HEADERS.contentEncoding, constants_1.BROTLI_ENCODING);
                }
                else if (downstreamIsGzipCompatible) {
                    response.setEncoder(zlib_1.default.createGzip({ chunkSize }));
                    response.setHeader(constants_1.HTTP_HEADERS.contentEncoding, constants_1.GZIP_ENCODING);
                }
                else if (downstreamIsDeflateCompatible) {
                    response.setEncoder(zlib_1.default.createDeflate({ chunkSize }));
                    response.setHeader(constants_1.HTTP_HEADERS.contentEncoding, constants_1.DEFLATE_ENCODING);
                }
            }
            else {
                response.removeHeader(constants_1.HTTP_HEADERS.contentEncoding);
            }
            response.initDownstream();
        }
    }
    // following response codes and methods were copied straight from sailfish -> some status codes arent encoded, and sailfish returns early
    isEncodable() {
        const responseCode = this.context.getResponse().statusCode;
        const method = this.context.getRequest().method.toUpperCase();
        if (method !== 'GET' && method !== 'POST' && method !== 'PUT') {
            return false;
        }
        return (responseCode < 400 &&
            ![100, 101, 204, 205, 206, 302, 304, 307].find(invalidCode => invalidCode === responseCode));
    }
    toString() {
        return 'ModTranscode';
    }
}
exports.default = ModTranscode;
