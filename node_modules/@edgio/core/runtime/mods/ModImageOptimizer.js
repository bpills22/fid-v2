"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Mod_1 = __importDefault(require("./Mod"));
const Phase_1 = __importDefault(require("../Phase"));
const environment_1 = require("../../environment");
const constants_1 = require("../../constants");
const http_1 = require("http");
const types_1 = require("../image-optimizer/types");
const ImageOptimizer_1 = require("../image-optimizer/ImageOptimizer");
const ImageOptimizerError_1 = require("../image-optimizer/ImageOptimizerError");
const log_1 = __importDefault(require("../../log"));
const ImageOptimizerConfigParser_1 = require("../image-optimizer/ImageOptimizerConfigParser");
const EarlyReturn_1 = __importDefault(require("../EarlyReturn"));
/**
 * Emulation of Sailfish's Image Optimizer.
 */
class ModImageOptimizer extends Mod_1.default {
    constructor() {
        super(...arguments);
        this.config = {};
    }
    async execute(phase) {
        const res = this.context.getResponse();
        try {
            // Check if the Image Optimizer is enabled and parse the config.
            if (Phase_1.default.UriClean === phase) {
                await this.handleUriClean();
            }
            // Perform the actual image optimization.
            if (Phase_1.default.SendRequestContent === phase) {
                await this.handleSendRequestContent();
            }
        }
        catch (e) {
            if (e instanceof ImageOptimizerError_1.ImageOptimizerError) {
                log_1.default.error(`[ModImageOptimizer] ${e.message}`);
                // Clear the image in response buffer
                res.clear();
                // Add header with error details.
                res.setHeader(constants_1.HTTP_HEADERS.xEdgeIoStatus, 'ERROR');
                res.setHeader(constants_1.HTTP_HEADERS.xEdgeIoError, e.message);
                res.setHeader(constants_1.HTTP_HEADERS.contentType, 'text/plain');
                // Set correct status code and message
                res.statusCode = 400;
                res.statusMessage = http_1.STATUS_CODES[400];
                res.body = `${res.statusCode} - ${res.statusMessage}`;
                res.chunks = [Buffer.from(res.body)];
                await res.end();
                throw new EarlyReturn_1.default('image_optimizer_error');
            }
            throw e;
        }
    }
    /**
     * In the UriClean phase, we check if the image optimization is enabled
     * and parse the config from the request query and headers.
     * This needs to be done before the ModStream runs,
     * so it can disable the streaming if the image optimization is enabled
     * for the given request.
     */
    async handleUriClean() {
        const req = this.context.getRequest();
        // Check if the Image Optimizer is enabled.
        // If not, we shouldn't even try to parse the config.
        this.context.optimizeImages = this.isEnabled();
        if (!this.context.optimizeImages)
            return;
        // Parse the config from the request query and headers.
        this.config = ImageOptimizerConfigParser_1.ImageOptimizerConfigParser.parseFromRequest(req);
        // Disable the Image Optimizer if no valid config was found
        // to avoid unnecessary processing.
        if (Object.keys(this.config).length === 0) {
            this.context.optimizeImages = false;
            log_1.default.debug(`[ModImageOptimizer] No valid config was found. Disabling the image optimization.`);
        }
    }
    /**
     * In the SendRequestContent phase,
     * right after the ModProxyCore has fetched the response from the origin
     * to buffer, we perform the actual image optimization.
     */
    async handleSendRequestContent() {
        const req = this.context.getRequest();
        const res = this.context.getResponse();
        // Do nothing if the Image Optimizer is disabled.
        if (!this.context.optimizeImages)
            return;
        // We'll just return the response unchanged,
        // if image cannot be optimized for some reason.
        if (!this.canOptimize()) {
            log_1.default.debug(`[ModImageOptimizer] The response cannot be optimized. Leaving the response unchanged.`);
            return;
        }
        log_1.default.trace(`[ModImageOptimizer] Optimizing the response.`);
        // Optimize the image in the response buffer.
        const optimizer = new ImageOptimizer_1.ImageOptimizer(this.config);
        const { output, metadata } = await optimizer.optimize(res.body);
        // Replace the current response buffer with the optimized image.
        res.clear();
        res.body = output;
        await res.write(output);
        await res.end();
        // Set correct content type if the format of the image was changed.
        if (this.config.format) {
            res.setHeader(constants_1.HTTP_HEADERS.contentType, types_1.SUPPORTED_TYPES[this.config.format]);
        }
        res.setHeader(constants_1.HTTP_HEADERS.xEdgeIoStatus, 'OK');
        // Return a debug header with metadata about the optimization, if requested.
        if (metadata && req.getHeader(constants_1.HTTP_HEADERS.xEcEdgeIoDebug)) {
            const { inputSize, outputSize, inputWidth, outputWidth, inputHeight, outputHeight, inputFormat, outputFormat, outputQuality, duration, } = metadata;
            res.setHeader(constants_1.HTTP_HEADERS.xEcEdgeIoDebug, `ifsz=${inputSize}; idim=${inputWidth}x${inputHeight}; ifmt=${inputFormat}; ofsz=${outputSize}; odim=${outputWidth}x${outputHeight}; ofmt=${outputFormat}; oq=${outputQuality}; ms=${duration}; cpu=1`);
        }
    }
    /**
     * Returns true if the response is compatible with the Image Optimizer
     * and can be optimized.
     */
    canOptimize() {
        var _a;
        const res = this.context.getResponse();
        const respHeaders = this.context.getResponse().getHeaders();
        const contentType = (_a = respHeaders[constants_1.HTTP_HEADERS.contentType]) === null || _a === void 0 ? void 0 : _a.toString();
        return Boolean(
        // The Image Optimizer can only optimize supported image types.
        contentType &&
            types_1.SUPPORTED_CONTENT_TYPES.includes(contentType) &&
            // The Image Optimizer can only optimize images up to 10MB.
            res.body &&
            Buffer.isBuffer(res.body) &&
            res.body.length <= types_1.MAX_IMAGE_SIZE);
    }
    /**
     * Returns true if the Image Optimizer is enabled.
     */
    isEnabled() {
        const res = this.context.getResponse();
        let optimizeImagesFeature = false;
        this.context.forEachMatchingRule(rule => {
            var _a, _b;
            // Image Optimization can be turned off by setting optimize_images to false in another matched rule.
            if (((_a = rule === null || rule === void 0 ? void 0 : rule.response) === null || _a === void 0 ? void 0 : _a.optimize_images) !== undefined)
                optimizeImagesFeature = (_b = rule === null || rule === void 0 ? void 0 : rule.response) === null || _b === void 0 ? void 0 : _b.optimize_images;
        });
        return Boolean(
        // The Image Optimizer is only available in the local environment
        (0, environment_1.isLocal)() &&
            // The Image Optimizer needs to be enabled in features
            optimizeImagesFeature &&
            // The Image Optimizer can be turned off by sending x-ec-edge-io-disable header
            !res.getHeader(constants_1.HTTP_HEADERS.xEcEdgeIoDisable));
    }
    toString() {
        return 'ModImageOptimizer';
    }
}
exports.default = ModImageOptimizer;
