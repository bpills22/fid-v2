"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Worker_1 = require("./Worker");
const Serializer_1 = require("./Serializer");
const buffer_1 = require("buffer");
const EdgeFunction_1 = __importDefault(require("./EdgeFunction"));
const EdgeFunctionError_1 = __importDefault(require("./EdgeFunctionError"));
const consts_1 = require("./consts");
class EdgeFunctionParentInterface {
    constructor() {
        this.started = false;
        this.port = Worker_1.parentPort;
        this.workerData = undefined;
        this.fetches_fifo_queue = [];
        this.response_chunks_fifo_queue = [];
    }
    startListening() {
        if (this.started) {
            return;
        }
        this.started = true;
        this.port.onmessage = async (event) => {
            const message = event.data;
            const { command } = message;
            // Here we receive the workerData sent by EdgeFunctionsManager
            if (command === 'init') {
                this.workerData = message.workerData;
                return;
            }
            // Skip all messages until we receive the workerData
            if (!this.workerData)
                return;
            if (command === 'run') {
                // Dedicated worker message channel port cannot be transferred
                // via the workerData, so we have to send it separately.
                this.port = message.port;
                try {
                    const fun = new EdgeFunction_1.default(this, this.workerData.params);
                    const response = await fun.run(message.wasmInitialMemory);
                    if (response === EdgeFunctionError_1.default.ErrorRunning) {
                        // This catches exceptions in the edge function.
                        this.port.postMessage(['done-exception', fun.getPanicString()]);
                    }
                    else {
                        this.port.postMessage(['done-response', response]);
                    }
                }
                catch (e) {
                    // This catches exceptions in the TypeScript.
                    this.port.postMessage(['done-error', e]);
                }
                return;
            }
            throw new Error(`Unknown command: ${command}`);
        };
    }
    fetchAsync(requestId, ...args) {
        this.port.postMessage(['fetch', requestId, ...args]);
    }
    enableResponseBodyChunkEvents(responseId) {
        this.port.postMessage(['enableResponseBodyChunkEvents', responseId]);
    }
    consumeNextResponseBodyChunkId() {
        this.port.postMessage(['consumeNextResponseBodyChunkId']);
    }
    queueResponseBodyChunkEvent(responseId) {
        this.port.postMessage(['queueResponseBodyChunkEvent', responseId]);
    }
    writeToStdout(buffer) {
        this.port.postMessage(['stdout', buffer]);
    }
    writeToStderr(buffer) {
        this.port.postMessage(['stderr', buffer]);
    }
    writeWasmInitialMemory(buffer) {
        this.port.postMessage(['wasmInitialMemory', buffer]);
    }
    clearWasmInitialMemory() {
        this.port.postMessage(['wasmClearMemory']);
    }
    writeToDebugStream(buffer) {
        this.port.postMessage(['debug', buffer]);
    }
    // This functions needs to match the logic in Sailfish. It will block until one of
    // the following events occurs (the order matters):
    // EVENT_ERROR - An error was encountered. (Not part of sailfish but added for SDK communications)
    // EVENT_IO_FETCH - A fetch response is ready.
    // EVENT_IO_RESPONSE_CHUNK - A response chunk is ready.
    waitNextIoReadySync() {
        var _a, _b;
        if (!this.workerData)
            return null;
        const { semaphore, exchangeBuffer, dataLength } = this.workerData;
        // Reset the waited on semaphore so that we are guaranteed a wait.
        // This will give time for the parent to get the message and process it.
        // Be sure to call Atomics.store() before postMessage(['waiting']) to avoid
        // the race condition where the worker sets the semaphore, but then the parent
        // resets it before if can wait on it.
        Atomics.store(semaphore, consts_1.SEMAPHORE_INDEX_WORKER_WAIT, consts_1.SEMAPHORE_VALUE_SHOULD_WAIT);
        // Signal to the parent that we are about to start waiting.
        this.port.postMessage(['waiting']);
        this.writeToDebugStream(buffer_1.Buffer.from(`waitNextIoReadySync(): Block until the next event...`));
        // Wait on the semaphore to change through the action of the parent.
        Atomics.wait(semaphore, consts_1.SEMAPHORE_INDEX_WORKER_WAIT, consts_1.SEMAPHORE_VALUE_SHOULD_WAIT);
        this.writeToDebugStream(buffer_1.Buffer.from(`waitNextIoReadySync(): received event.`));
        // Deserialize the response from the exchange buffer.
        const length = dataLength[0];
        const message = Serializer_1.Serializer.deserialize(buffer_1.Buffer.from(exchangeBuffer, 0, length));
        switch (message.event) {
            case consts_1.EVENT_ERROR:
                this.writeToDebugStream(buffer_1.Buffer.from(`waitNextIoReadySync(): EVENT_ERROR: ${message.error}`));
                throw new Error(`Error in the worker: ${message.error}`);
            case consts_1.EVENT_IO_FETCH:
                // Reinstate the body buffer as a Buffer object.
                if ((_a = message.response) === null || _a === void 0 ? void 0 : _a.body) {
                    message.response.body = buffer_1.Buffer.from((_b = message.response) === null || _b === void 0 ? void 0 : _b.body);
                }
                this.fetches_fifo_queue.push(message);
                break;
            case consts_1.EVENT_IO_RESPONSE_CHUNK:
                this.response_chunks_fifo_queue.push(message.responseId);
                break;
            default:
                throw new Error(`waitNextIoReadySync(): Unexpected message event: ${message.event}`);
        }
        this.writeToDebugStream(buffer_1.Buffer.from(`waitNextIoReadySync(): returns ${(0, consts_1.eventToString)(message.event)}`));
        return message.event;
    }
    getNextFetch() {
        if (this.fetches_fifo_queue.length === 0) {
            // Return the same error as Sailfish in event.cc::hostcall_event_get_fetch_id
            throw new Error(`hostcall_event_get_fetch_id: There are no pending fetches ready.`);
        }
        return this.fetches_fifo_queue.shift();
    }
    getNextBodyChunkResponseId() {
        if (this.response_chunks_fifo_queue.length === 0) {
            // Return the same error as Sailfish in event.cc::hostcall_event_response_chunk_get_response_id
            throw new Error(`hostcall_event_response_chunk_get_response_id: There are no pending response body chunks ready.`);
        }
        this.consumeNextResponseBodyChunkId();
        return this.response_chunks_fifo_queue.shift();
    }
    get path() {
        var _a, _b;
        return (_b = (_a = this.workerData) === null || _a === void 0 ? void 0 : _a.params.path) !== null && _b !== void 0 ? _b : 'Unknown';
    }
}
exports.default = EdgeFunctionParentInterface;
