"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const EdgeFunctionHeaders_1 = __importDefault(require("./EdgeFunctionHeaders"));
const buffer_1 = require("buffer");
class EdgeFunctionResponse {
    /**
     * Creates a new EdgeFunctionResponse out of any object that fulfils basic interface of a generalized Response.
     */
    constructor({ statusCode, statusMessage, body, headers, }) {
        this.statusCode = statusCode || 0; // Connascence of the value in Sailfish. See http_message.h
        this.statusMessage = statusMessage;
        if (buffer_1.Buffer.isBuffer(body) || typeof body === 'string' || body instanceof Uint8Array) {
            // Subtle issue here. We must copy the body because the buffer that the response
            // arrived in is shared by the parent/worker threads and v8.deserialize does shallow copy on buffers.
            // Hence if we don't copy it, this body will be overwritten by the next response that comes in.
            // body can be overwritten by the next response that comes in.
            this.body = buffer_1.Buffer.from(body);
        }
        this.bodyBytesRead = 0;
        this.headers = new EdgeFunctionHeaders_1.default(headers);
        this.responseReturned = false;
        this.responseBodyFinalized = false;
        this.responseBodyChunksReadEndOfStreamSent = false;
    }
    hasChunksToRead() {
        // Return true if are more chunks to read from the response body, or we have read the chunks,
        // but not yet sent the end of stream signal.
        return (!!this.body &&
            (this.bodyBytesRead < this.body.byteLength || !this.responseBodyChunksReadEndOfStreamSent));
    }
    // When streaming, track the number of bytes read from the response body so far.
    readStreamingBodyChunk(maxChunkSize) {
        return this.readBodyChunk(this.bodyBytesRead, maxChunkSize);
    }
    // Reads the body chunk. Returns an undefined if the data cannot be read.
    readBodyChunk(chunkOffset, maxChunkSize) {
        if (chunkOffset < 0) {
            throw new Error('chunkOffset must be greater than or equal to 0');
        }
        if (maxChunkSize <= 0) {
            throw new Error('maxChunkSize must be greater than 0');
        }
        if (!this.body) {
            return undefined;
        }
        if (chunkOffset >= this.body.byteLength) {
            this.responseBodyChunksReadEndOfStreamSent = true;
            return undefined;
        }
        const bytesToRead = Math.min(maxChunkSize, this.body.byteLength - chunkOffset);
        const chunk = this.body.slice(chunkOffset, chunkOffset + bytesToRead);
        this.bodyBytesRead += chunk.byteLength;
        return chunk;
    }
    static createFromResponse(response) {
        const clone_response = new EdgeFunctionResponse({
            statusCode: response.statusCode,
            statusMessage: response.statusMessage,
            body: '',
            headers: response.headers.headers(),
        });
        return clone_response;
    }
}
exports.default = EdgeFunctionResponse;
