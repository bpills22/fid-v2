"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const RequestContext_1 = __importDefault(require("./RequestContext"));
const log_1 = __importDefault(require("../log"));
const PropertyContext_1 = __importDefault(require("./PropertyContext"));
const REDIRECT_STATUS_CODES = new Set([301, 302, 303, 307, 308]);
class RequestHandler {
    constructor(options) {
        this.options = options;
    }
    async handleServerless(request, response) {
        await this.handle(request, response, async (context) => {
            await context.executeServerless();
        });
    }
    async handleSimulator(request, response) {
        await this.handle(request, response, async (context) => {
            await context.executeSimulator();
        });
    }
    async handle(request, response, callback) {
        log_1.default.debug(`[RequestHandler] ${request.method} ${request.url}`);
        const context = this.createRequestContext(request, response);
        await callback(context);
        if (context.followRedirects && REDIRECT_STATUS_CODES.has(response.statusCode)) {
            const res = await RequestHandler.recreateRequestResponse(request, response);
            const redirectContext = this.createRequestContext(res.request, res.response);
            await callback(redirectContext);
            // Sailfish only allows a single redirect. If the user attempts a second, it will throw a 500 error.
            if (context.followRedirects && REDIRECT_STATUS_CODES.has(response.statusCode))
                throw new Error('Too many internal redirects');
        }
        log_1.default.debug(`[RequestHandler] response : ${response.statusCode} ${response.statusMessage || ''}`);
    }
    createRequestContext(request, response) {
        return new RequestContext_1.default({
            request,
            response,
            propertyContext: new PropertyContext_1.default(this.options.config),
            rules: this.options.router.rules,
            edgeFunctions: this.options.config.edge_functions,
            cache: this.options.cache,
            functions: this.options.router.functions,
            interpolationValues: this.options.config.interpolationValues,
        });
    }
    /**
     * Recreates the request and response objects based on redirect location value
     */
    static async recreateRequestResponse(request, response) {
        const location = response.getHeader('location');
        const url = new URL(location);
        // Clone the request and use the redirect location as the URL
        const clone = request.cloneOriginal();
        clone.url = url.pathname + url.search;
        clone.path = url.pathname;
        // Undo any changes to the response made by the original request
        response.clear();
        response.clearHeaders();
        response.statusCode = 200;
        response.statusMessage = 'OK';
        response.body = '';
        return { request: clone, response };
    }
}
exports.default = RequestHandler;
