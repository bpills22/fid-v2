"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Origin_1 = __importDefault(require("./Origin"));
const constants_1 = require("../constants");
const BackendFetchError_1 = __importDefault(require("../errors/BackendFetchError"));
const errors_1 = require("../errors");
const log_1 = __importDefault(require("../log"));
/**
 * Helper class for fetching from origins
 * which allows to follow redirects to different origin.
 *
 * All redirect locations need to be configured in the edgio.config.js with exact hostname in
 * hostnames section otherwise the default origin will be used.
 *
 */
class OriginFetcher {
    constructor(propertyContext) {
        this.propertyContext = propertyContext;
    }
    /**
     * Fetches a response from the origin and follows redirects based on provided options.
     * @param req The request
     * @param res The response
     * @param options Additional options for this single fetch request
     * @param providedOriginName The origin name to be used. If not provided, the origin name will be extracted from the request.
     */
    async fetch(req, res, options, providedOriginName) {
        options = options || {};
        const originName = providedOriginName || this.propertyContext.getDefaultOrigin(req);
        const originConfig = this.propertyContext.getOrigin(originName);
        if (!originConfig) {
            throw new errors_1.EdgioProjectError(`Upstream origin '${originName}' doesn't exist.`);
        }
        try {
            await new Origin_1.default(originConfig).fetch(req, res, options);
        }
        catch (e) {
            // BackendFetchErrors are expected errors.
            // We need to handle them to allow Router.catch retries,
            // response manipulation in transformResponse, etc.
            if (e instanceof BackendFetchError_1.default) {
                log_1.default.error(`[OriginFetcher] Upstream origin '${originName}' fetch failed: ${e.message}`);
                return convertBackendErrorToResponse(e, res);
            }
            throw e;
        }
        // if we get 416, we're out of range -> we refetch full asset if ignoreUnsatisfiableRanges
        if (res.statusCode === 416 && options.ignoreUnsatisfiableRanges) {
            req.removeHeader(constants_1.HTTP_HEADERS.range);
            res.clear();
            return this.fetch(req, res, options);
        }
    }
    /**
     * Removes sensitive headers from the request.
     * @param req
     */
    removeSensitiveHeaders(req) {
        req.removeHeader('authorization');
        req.removeHeader('cookie');
    }
}
exports.default = OriginFetcher;
function convertBackendErrorToResponse(e, res) {
    var _a;
    res.clear();
    res.clearHeaders();
    res.setHeader(constants_1.HTTP_HEADERS.xEdgServerlessError, e.message);
    if (((_a = e.cause) === null || _a === void 0 ? void 0 : _a.code) === 'ETIMEDOUT') {
        res.statusCode = 504;
        res.statusMessage = 'Gateway Timeout';
        res.body = '504 - Gateway Timeout';
        return;
    }
    res.statusCode = 502;
    res.statusMessage = 'Bad Gateway';
    res.body = '502 - Bad Gateway';
}
