"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.containsEdgeFunctionFeature = exports.forceEdgeFunctionFeatureObject = exports.forEachFeature = exports.getEdgeFunctionFiles = exports.getEdgeFunctionFeatures = exports.getEdgeFunctionJsPath = void 0;
const path_1 = require("path");
/**
 * Gets the js_path specified from the EdgeFunction
 */
function getEdgeFunctionJsPath(edgeFunction) {
    if (typeof edgeFunction === 'string') {
        return edgeFunction;
    }
    else if (edgeFunction.js_path) {
        return edgeFunction.js_path;
    }
    throw new Error('Edge function path not specified');
}
exports.getEdgeFunctionJsPath = getEdgeFunctionJsPath;
/**
 * Returns an array containing all rules that contain the edge_function feature.
 * @param rules The router rules
 * @returns
 */
function getEdgeFunctionFeatures(rules) {
    const features = [];
    forEachFeature(rules, feature => {
        if (feature.edge_function) {
            features.push(feature);
        }
    });
    return features;
}
exports.getEdgeFunctionFeatures = getEdgeFunctionFeatures;
/**
 * Returns an array containing all the edge function files
 * referenced by the specified rules.
 * @param rules The router rules
 */
function getEdgeFunctionFiles(rules) {
    let fileList = new Set();
    for (let feature of getEdgeFunctionFeatures(rules)) {
        const srcPath = getEdgeFunctionJsPath(feature.edge_function);
        const fileGlob = (0, path_1.join)((0, path_1.resolve)((0, path_1.dirname)(srcPath)), '*.js');
        fileList.add(fileGlob);
    }
    return Array.from(fileList);
}
exports.getEdgeFunctionFiles = getEdgeFunctionFiles;
/**
 * Calls the specified callback for each feature in the rules array
 * @param rules The rules to traverse
 * @param callback The callback to call with each feature
 */
function forEachFeature(rules, callback) {
    if (Array.isArray(rules)) {
        for (let item of rules) {
            forEachFeature(item, callback);
        }
    }
    else if (typeof rules === 'object') {
        callback(rules);
        for (const key in rules) {
            forEachFeature(rules[key], callback);
        }
    }
}
exports.forEachFeature = forEachFeature;
/**
 * Converts all edge_function features from the legacy EdgeFunctionPath to EdgeFunctionObject.
 * @param rules The rules to traverse
 */
function forceEdgeFunctionFeatureObject(rules, default_version_number) {
    forEachFeature(rules, feature => {
        if (feature.edge_function) {
            if (typeof feature.edge_function === 'string') {
                const js_path = feature.edge_function;
                feature.edge_function = {
                    js_path: js_path,
                    version: default_version_number,
                };
            }
        }
    });
}
exports.forceEdgeFunctionFeatureObject = forceEdgeFunctionFeatureObject;
/**
 * Returns true when specified rules contain
 * at least one edge_function feature.
 */
function containsEdgeFunctionFeature(rules) {
    return getEdgeFunctionFeatures(rules).length > 0;
}
exports.containsEdgeFunctionFeature = containsEdgeFunctionFeature;
