"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbsoluteFolderName = void 0;
const AbsoluteFileName_1 = require("./AbsoluteFileName");
const Envirovment_1 = require("./Envirovment");
const FileName_1 = require("./FileName");
const Name_1 = require("./Name");
const normalizePath_1 = require("./utils/normalizePath");
const fs_1 = __importDefault(require("fs"));
/**
 * Absolute folder name is a folder name that starts with slash and can contain parent folder that
 * must be absolute folder name or undefined (if folder is at the root)
 */
class AbsoluteFolderName {
    constructor(name, parent) {
        if (typeof name === "string") {
            const parsed = AbsoluteFolderName.parse(name);
            this.parent = parsed[1];
            this.name = parsed[0];
        }
        else {
            this.parent = parent;
            this.name = name;
        }
        this.value = this.parent ?
            `${this.parent.value}/${this.name.value}` :
            `${this.name.value}`;
    }
    file(fileName, type) {
        if (typeof fileName === "string")
            return new AbsoluteFileName_1.AbsoluteFileName(new FileName_1.FileName(fileName), this, type);
        else
            return new AbsoluteFileName_1.AbsoluteFileName(fileName, this, type);
    }
    folder(folderName) {
        if (typeof folderName === "string")
            return new AbsoluteFolderName(new Name_1.Name(folderName), this);
        else
            return new AbsoluteFolderName(folderName, this);
    }
    with(children) {
        const newDefinition = new AbsoluteFolderName(this.name, this.parent);
        const res = children(newDefinition);
        newDefinition.setChildren(res);
        return newDefinition;
    }
    setChildren(children) {
        // read keys/values from children and inject into this class
        for (const key in children) {
            this[key] = children[key];
        }
    }
    exists() {
        return fs_1.default.existsSync(this.value);
    }
    create(ignoreExisting) {
        if (!this.exists()) {
            fs_1.default.mkdirSync(this.value, { recursive: true });
            return;
        }
        if (!ignoreExisting)
            throw new Error(`Folder ${this.value} already exists`);
    }
    recreate() {
        this.delete(true);
        fs_1.default.mkdirSync(this.value, { recursive: true });
    }
    delete(ignoreIfNotExists) {
        if (this.exists()) {
            fs_1.default.rmSync(this.value, { recursive: true });
            return;
        }
        if (!ignoreIfNotExists)
            throw new Error(`Folder ${this.value} doesn't exist`);
    }
    static from(source) {
        return new AbsoluteFolderName(source);
    }
}
exports.AbsoluteFolderName = AbsoluteFolderName;
AbsoluteFolderName.parse = (name) => {
    if ((0, Envirovment_1.isRelativePath)(name))
        throw new Error(`AbsoulteFolderName must start with ${Envirovment_1.context.isWindows ? "drive name" : "slash"}, did you mean RelativeFolderName?`);
    const normalized = (0, normalizePath_1.normalizePath)(name);
    const lastSlashIndex = normalized.lastIndexOf("/");
    if (lastSlashIndex === -1) {
        return [new Name_1.Name(normalized), undefined];
    }
    const rest = normalized.substring(0, lastSlashIndex);
    const parent = new AbsoluteFolderName(rest.length === 0 ? "/" : rest);
    const folder = new Name_1.Name(normalized.substring(lastSlashIndex + 1));
    return [folder, parent];
};
