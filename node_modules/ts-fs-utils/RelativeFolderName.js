"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RelativeFolderName = void 0;
const Envirovment_1 = require("./Envirovment");
const Name_1 = require("./Name");
const Lazy_1 = require("./utils/Lazy");
const normalizePath_1 = require("./utils/normalizePath");
/**
 * Relative folder name is a folder name that can contain parent folder that
 * must be relative folder name or undefined (if folder is at the root)
 */
class RelativeFolderName {
    constructor(p1, p2) {
        this.value = "";
        if (typeof p1 === "string") {
            const parsed = RelativeFolderName.parse(p1);
            this.parent = parsed[0];
            this.folder = parsed[1];
        }
        else {
            this.parent = p2;
            this.folder = p1;
        }
        this.value = this.parent ?
            this.parent.value + "/" + this.folder.value :
            this.folder.value;
        this.fullPathLazy = new Lazy_1.Lazy(() => {
            return this.parent
                ? this.parent.fullPath + "/" + this.folder.value
                : this.folder.value;
        });
    }
    get fullPath() { return this.fullPathLazy.value; }
    static from(source) {
        return new RelativeFolderName(source);
    }
}
exports.RelativeFolderName = RelativeFolderName;
RelativeFolderName.parse = (name) => {
    if ((0, Envirovment_1.isAbsolutePath)(name))
        throw new Error("RelativeFolderName cannot start with slash, did you mean AbsoluteFolderName?");
    const normalized = (0, normalizePath_1.normalizePath)(name);
    const lastSlashIndex = normalized.lastIndexOf("/");
    if (lastSlashIndex > -1) {
        const parent = new RelativeFolderName(normalized.substring(0, lastSlashIndex));
        const folder = new Name_1.Name(normalized.substring(lastSlashIndex + 1));
        return [parent, folder];
    }
    else {
        const parent = undefined;
        const folder = new Name_1.Name(normalized);
        return [parent, folder];
    }
};
